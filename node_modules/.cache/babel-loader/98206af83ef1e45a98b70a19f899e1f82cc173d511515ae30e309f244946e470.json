{"ast":null,"code":"import { SerdeContext } from \"@smithy/core/protocols\";\nimport { NormalizedSchema } from \"@smithy/core/schema\";\nimport { _parseEpochTimestamp, generateIdempotencyToken } from \"@smithy/core/serde\";\nimport { fromBase64 } from \"@smithy/util-base64\";\nimport { cbor } from \"./cbor\";\nimport { dateToTag } from \"./parseCborBody\";\nexport class CborCodec extends SerdeContext {\n  createSerializer() {\n    const serializer = new CborShapeSerializer();\n    serializer.setSerdeContext(this.serdeContext);\n    return serializer;\n  }\n  createDeserializer() {\n    const deserializer = new CborShapeDeserializer();\n    deserializer.setSerdeContext(this.serdeContext);\n    return deserializer;\n  }\n}\nexport class CborShapeSerializer extends SerdeContext {\n  value;\n  write(schema, value) {\n    this.value = this.serialize(schema, value);\n  }\n  serialize(schema, source) {\n    const ns = NormalizedSchema.of(schema);\n    if (source == null) {\n      if (ns.isIdempotencyToken()) {\n        return generateIdempotencyToken();\n      }\n      return source;\n    }\n    if (ns.isBlobSchema()) {\n      if (typeof source === \"string\") {\n        return (this.serdeContext?.base64Decoder ?? fromBase64)(source);\n      }\n      return source;\n    }\n    if (ns.isTimestampSchema()) {\n      if (typeof source === \"number\" || typeof source === \"bigint\") {\n        return dateToTag(new Date(Number(source) / 1000 | 0));\n      }\n      return dateToTag(source);\n    }\n    if (typeof source === \"function\" || typeof source === \"object\") {\n      const sourceObject = source;\n      if (ns.isListSchema() && Array.isArray(sourceObject)) {\n        const sparse = !!ns.getMergedTraits().sparse;\n        const newArray = [];\n        let i = 0;\n        for (const item of sourceObject) {\n          const value = this.serialize(ns.getValueSchema(), item);\n          if (value != null || sparse) {\n            newArray[i++] = value;\n          }\n        }\n        return newArray;\n      }\n      if (sourceObject instanceof Date) {\n        return dateToTag(sourceObject);\n      }\n      const newObject = {};\n      if (ns.isMapSchema()) {\n        const sparse = !!ns.getMergedTraits().sparse;\n        for (const key of Object.keys(sourceObject)) {\n          const value = this.serialize(ns.getValueSchema(), sourceObject[key]);\n          if (value != null || sparse) {\n            newObject[key] = value;\n          }\n        }\n      } else if (ns.isStructSchema()) {\n        for (const [key, memberSchema] of ns.structIterator()) {\n          const value = this.serialize(memberSchema, sourceObject[key]);\n          if (value != null) {\n            newObject[key] = value;\n          }\n        }\n      } else if (ns.isDocumentSchema()) {\n        for (const key of Object.keys(sourceObject)) {\n          newObject[key] = this.serialize(ns.getValueSchema(), sourceObject[key]);\n        }\n      }\n      return newObject;\n    }\n    return source;\n  }\n  flush() {\n    const buffer = cbor.serialize(this.value);\n    this.value = undefined;\n    return buffer;\n  }\n}\nexport class CborShapeDeserializer extends SerdeContext {\n  read(schema, bytes) {\n    const data = cbor.deserialize(bytes);\n    return this.readValue(schema, data);\n  }\n  readValue(_schema, value) {\n    const ns = NormalizedSchema.of(_schema);\n    if (ns.isTimestampSchema() && typeof value === \"number\") {\n      return _parseEpochTimestamp(value);\n    }\n    if (ns.isBlobSchema()) {\n      if (typeof value === \"string\") {\n        return (this.serdeContext?.base64Decoder ?? fromBase64)(value);\n      }\n      return value;\n    }\n    if (typeof value === \"undefined\" || typeof value === \"boolean\" || typeof value === \"number\" || typeof value === \"string\" || typeof value === \"bigint\" || typeof value === \"symbol\") {\n      return value;\n    } else if (typeof value === \"function\" || typeof value === \"object\") {\n      if (value === null) {\n        return null;\n      }\n      if (\"byteLength\" in value) {\n        return value;\n      }\n      if (value instanceof Date) {\n        return value;\n      }\n      if (ns.isDocumentSchema()) {\n        return value;\n      }\n      if (ns.isListSchema()) {\n        const newArray = [];\n        const memberSchema = ns.getValueSchema();\n        const sparse = !!ns.getMergedTraits().sparse;\n        for (const item of value) {\n          const itemValue = this.readValue(memberSchema, item);\n          if (itemValue != null || sparse) {\n            newArray.push(itemValue);\n          }\n        }\n        return newArray;\n      }\n      const newObject = {};\n      if (ns.isMapSchema()) {\n        const sparse = !!ns.getMergedTraits().sparse;\n        const targetSchema = ns.getValueSchema();\n        for (const key of Object.keys(value)) {\n          const itemValue = this.readValue(targetSchema, value[key]);\n          if (itemValue != null || sparse) {\n            newObject[key] = itemValue;\n          }\n        }\n      } else if (ns.isStructSchema()) {\n        for (const [key, memberSchema] of ns.structIterator()) {\n          const v = this.readValue(memberSchema, value[key]);\n          if (v != null) {\n            newObject[key] = v;\n          }\n        }\n      }\n      return newObject;\n    } else {\n      return value;\n    }\n  }\n}","map":{"version":3,"names":["SerdeContext","NormalizedSchema","_parseEpochTimestamp","generateIdempotencyToken","fromBase64","cbor","dateToTag","CborCodec","createSerializer","serializer","CborShapeSerializer","setSerdeContext","serdeContext","createDeserializer","deserializer","CborShapeDeserializer","value","write","schema","serialize","source","ns","of","isIdempotencyToken","isBlobSchema","base64Decoder","isTimestampSchema","Date","Number","sourceObject","isListSchema","Array","isArray","sparse","getMergedTraits","newArray","i","item","getValueSchema","newObject","isMapSchema","key","Object","keys","isStructSchema","memberSchema","structIterator","isDocumentSchema","flush","buffer","undefined","read","bytes","data","deserialize","readValue","_schema","itemValue","push","targetSchema","v"],"sources":["D:/ITechArt/react-lab-2025/application/node_modules/@aws-sdk/middleware-sdk-s3/node_modules/@smithy/core/dist-es/submodules/cbor/CborCodec.js"],"sourcesContent":["import { SerdeContext } from \"@smithy/core/protocols\";\nimport { NormalizedSchema } from \"@smithy/core/schema\";\nimport { _parseEpochTimestamp, generateIdempotencyToken } from \"@smithy/core/serde\";\nimport { fromBase64 } from \"@smithy/util-base64\";\nimport { cbor } from \"./cbor\";\nimport { dateToTag } from \"./parseCborBody\";\nexport class CborCodec extends SerdeContext {\n    createSerializer() {\n        const serializer = new CborShapeSerializer();\n        serializer.setSerdeContext(this.serdeContext);\n        return serializer;\n    }\n    createDeserializer() {\n        const deserializer = new CborShapeDeserializer();\n        deserializer.setSerdeContext(this.serdeContext);\n        return deserializer;\n    }\n}\nexport class CborShapeSerializer extends SerdeContext {\n    value;\n    write(schema, value) {\n        this.value = this.serialize(schema, value);\n    }\n    serialize(schema, source) {\n        const ns = NormalizedSchema.of(schema);\n        if (source == null) {\n            if (ns.isIdempotencyToken()) {\n                return generateIdempotencyToken();\n            }\n            return source;\n        }\n        if (ns.isBlobSchema()) {\n            if (typeof source === \"string\") {\n                return (this.serdeContext?.base64Decoder ?? fromBase64)(source);\n            }\n            return source;\n        }\n        if (ns.isTimestampSchema()) {\n            if (typeof source === \"number\" || typeof source === \"bigint\") {\n                return dateToTag(new Date((Number(source) / 1000) | 0));\n            }\n            return dateToTag(source);\n        }\n        if (typeof source === \"function\" || typeof source === \"object\") {\n            const sourceObject = source;\n            if (ns.isListSchema() && Array.isArray(sourceObject)) {\n                const sparse = !!ns.getMergedTraits().sparse;\n                const newArray = [];\n                let i = 0;\n                for (const item of sourceObject) {\n                    const value = this.serialize(ns.getValueSchema(), item);\n                    if (value != null || sparse) {\n                        newArray[i++] = value;\n                    }\n                }\n                return newArray;\n            }\n            if (sourceObject instanceof Date) {\n                return dateToTag(sourceObject);\n            }\n            const newObject = {};\n            if (ns.isMapSchema()) {\n                const sparse = !!ns.getMergedTraits().sparse;\n                for (const key of Object.keys(sourceObject)) {\n                    const value = this.serialize(ns.getValueSchema(), sourceObject[key]);\n                    if (value != null || sparse) {\n                        newObject[key] = value;\n                    }\n                }\n            }\n            else if (ns.isStructSchema()) {\n                for (const [key, memberSchema] of ns.structIterator()) {\n                    const value = this.serialize(memberSchema, sourceObject[key]);\n                    if (value != null) {\n                        newObject[key] = value;\n                    }\n                }\n            }\n            else if (ns.isDocumentSchema()) {\n                for (const key of Object.keys(sourceObject)) {\n                    newObject[key] = this.serialize(ns.getValueSchema(), sourceObject[key]);\n                }\n            }\n            return newObject;\n        }\n        return source;\n    }\n    flush() {\n        const buffer = cbor.serialize(this.value);\n        this.value = undefined;\n        return buffer;\n    }\n}\nexport class CborShapeDeserializer extends SerdeContext {\n    read(schema, bytes) {\n        const data = cbor.deserialize(bytes);\n        return this.readValue(schema, data);\n    }\n    readValue(_schema, value) {\n        const ns = NormalizedSchema.of(_schema);\n        if (ns.isTimestampSchema() && typeof value === \"number\") {\n            return _parseEpochTimestamp(value);\n        }\n        if (ns.isBlobSchema()) {\n            if (typeof value === \"string\") {\n                return (this.serdeContext?.base64Decoder ?? fromBase64)(value);\n            }\n            return value;\n        }\n        if (typeof value === \"undefined\" ||\n            typeof value === \"boolean\" ||\n            typeof value === \"number\" ||\n            typeof value === \"string\" ||\n            typeof value === \"bigint\" ||\n            typeof value === \"symbol\") {\n            return value;\n        }\n        else if (typeof value === \"function\" || typeof value === \"object\") {\n            if (value === null) {\n                return null;\n            }\n            if (\"byteLength\" in value) {\n                return value;\n            }\n            if (value instanceof Date) {\n                return value;\n            }\n            if (ns.isDocumentSchema()) {\n                return value;\n            }\n            if (ns.isListSchema()) {\n                const newArray = [];\n                const memberSchema = ns.getValueSchema();\n                const sparse = !!ns.getMergedTraits().sparse;\n                for (const item of value) {\n                    const itemValue = this.readValue(memberSchema, item);\n                    if (itemValue != null || sparse) {\n                        newArray.push(itemValue);\n                    }\n                }\n                return newArray;\n            }\n            const newObject = {};\n            if (ns.isMapSchema()) {\n                const sparse = !!ns.getMergedTraits().sparse;\n                const targetSchema = ns.getValueSchema();\n                for (const key of Object.keys(value)) {\n                    const itemValue = this.readValue(targetSchema, value[key]);\n                    if (itemValue != null || sparse) {\n                        newObject[key] = itemValue;\n                    }\n                }\n            }\n            else if (ns.isStructSchema()) {\n                for (const [key, memberSchema] of ns.structIterator()) {\n                    const v = this.readValue(memberSchema, value[key]);\n                    if (v != null) {\n                        newObject[key] = v;\n                    }\n                }\n            }\n            return newObject;\n        }\n        else {\n            return value;\n        }\n    }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}