{"ast":null,"code":"export class TypeRegistry {\n  namespace;\n  schemas;\n  exceptions;\n  static registries = new Map();\n  constructor(namespace, schemas = new Map(), exceptions = new Map()) {\n    this.namespace = namespace;\n    this.schemas = schemas;\n    this.exceptions = exceptions;\n  }\n  static for(namespace) {\n    if (!TypeRegistry.registries.has(namespace)) {\n      TypeRegistry.registries.set(namespace, new TypeRegistry(namespace));\n    }\n    return TypeRegistry.registries.get(namespace);\n  }\n  register(shapeId, schema) {\n    const qualifiedName = this.normalizeShapeId(shapeId);\n    const registry = TypeRegistry.for(qualifiedName.split(\"#\")[0]);\n    registry.schemas.set(qualifiedName, schema);\n  }\n  getSchema(shapeId) {\n    const id = this.normalizeShapeId(shapeId);\n    if (!this.schemas.has(id)) {\n      throw new Error(`@smithy/core/schema - schema not found for ${id}`);\n    }\n    return this.schemas.get(id);\n  }\n  registerError(es, ctor) {\n    const $error = es;\n    const registry = TypeRegistry.for($error[1]);\n    registry.schemas.set($error[1] + \"#\" + $error[2], $error);\n    registry.exceptions.set($error, ctor);\n  }\n  getErrorCtor(es) {\n    const $error = es;\n    const registry = TypeRegistry.for($error[1]);\n    return registry.exceptions.get($error);\n  }\n  getBaseException() {\n    for (const exceptionKey of this.exceptions.keys()) {\n      if (Array.isArray(exceptionKey)) {\n        const [, ns, name] = exceptionKey;\n        const id = ns + \"#\" + name;\n        if (id.startsWith(\"smithy.ts.sdk.synthetic.\") && id.endsWith(\"ServiceException\")) {\n          return exceptionKey;\n        }\n      }\n    }\n    return undefined;\n  }\n  find(predicate) {\n    return [...this.schemas.values()].find(predicate);\n  }\n  clear() {\n    this.schemas.clear();\n    this.exceptions.clear();\n  }\n  normalizeShapeId(shapeId) {\n    if (shapeId.includes(\"#\")) {\n      return shapeId;\n    }\n    return this.namespace + \"#\" + shapeId;\n  }\n}","map":{"version":3,"names":["TypeRegistry","namespace","schemas","exceptions","registries","Map","constructor","for","has","set","get","register","shapeId","schema","qualifiedName","normalizeShapeId","registry","split","getSchema","id","Error","registerError","es","ctor","$error","getErrorCtor","getBaseException","exceptionKey","keys","Array","isArray","ns","name","startsWith","endsWith","undefined","find","predicate","values","clear","includes"],"sources":["D:/ITechArt/react-lab-2025/application/node_modules/@aws-sdk/s3-request-presigner/node_modules/@smithy/core/dist-es/submodules/schema/TypeRegistry.js"],"sourcesContent":["export class TypeRegistry {\n    namespace;\n    schemas;\n    exceptions;\n    static registries = new Map();\n    constructor(namespace, schemas = new Map(), exceptions = new Map()) {\n        this.namespace = namespace;\n        this.schemas = schemas;\n        this.exceptions = exceptions;\n    }\n    static for(namespace) {\n        if (!TypeRegistry.registries.has(namespace)) {\n            TypeRegistry.registries.set(namespace, new TypeRegistry(namespace));\n        }\n        return TypeRegistry.registries.get(namespace);\n    }\n    register(shapeId, schema) {\n        const qualifiedName = this.normalizeShapeId(shapeId);\n        const registry = TypeRegistry.for(qualifiedName.split(\"#\")[0]);\n        registry.schemas.set(qualifiedName, schema);\n    }\n    getSchema(shapeId) {\n        const id = this.normalizeShapeId(shapeId);\n        if (!this.schemas.has(id)) {\n            throw new Error(`@smithy/core/schema - schema not found for ${id}`);\n        }\n        return this.schemas.get(id);\n    }\n    registerError(es, ctor) {\n        const $error = es;\n        const registry = TypeRegistry.for($error[1]);\n        registry.schemas.set($error[1] + \"#\" + $error[2], $error);\n        registry.exceptions.set($error, ctor);\n    }\n    getErrorCtor(es) {\n        const $error = es;\n        const registry = TypeRegistry.for($error[1]);\n        return registry.exceptions.get($error);\n    }\n    getBaseException() {\n        for (const exceptionKey of this.exceptions.keys()) {\n            if (Array.isArray(exceptionKey)) {\n                const [, ns, name] = exceptionKey;\n                const id = ns + \"#\" + name;\n                if (id.startsWith(\"smithy.ts.sdk.synthetic.\") && id.endsWith(\"ServiceException\")) {\n                    return exceptionKey;\n                }\n            }\n        }\n        return undefined;\n    }\n    find(predicate) {\n        return [...this.schemas.values()].find(predicate);\n    }\n    clear() {\n        this.schemas.clear();\n        this.exceptions.clear();\n    }\n    normalizeShapeId(shapeId) {\n        if (shapeId.includes(\"#\")) {\n            return shapeId;\n        }\n        return this.namespace + \"#\" + shapeId;\n    }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}