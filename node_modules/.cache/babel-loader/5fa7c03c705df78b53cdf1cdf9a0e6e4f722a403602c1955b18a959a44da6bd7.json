{"ast":null,"code":"import { isThrottlingError } from \"@smithy/service-error-classification\";\nexport class DefaultRateLimiter {\n  static setTimeoutFn = setTimeout;\n  beta;\n  minCapacity;\n  minFillRate;\n  scaleConstant;\n  smooth;\n  currentCapacity = 0;\n  enabled = false;\n  lastMaxRate = 0;\n  measuredTxRate = 0;\n  requestCount = 0;\n  fillRate;\n  lastThrottleTime;\n  lastTimestamp = 0;\n  lastTxRateBucket;\n  maxCapacity;\n  timeWindow = 0;\n  constructor(options) {\n    this.beta = options?.beta ?? 0.7;\n    this.minCapacity = options?.minCapacity ?? 1;\n    this.minFillRate = options?.minFillRate ?? 0.5;\n    this.scaleConstant = options?.scaleConstant ?? 0.4;\n    this.smooth = options?.smooth ?? 0.8;\n    const currentTimeInSeconds = this.getCurrentTimeInSeconds();\n    this.lastThrottleTime = currentTimeInSeconds;\n    this.lastTxRateBucket = Math.floor(this.getCurrentTimeInSeconds());\n    this.fillRate = this.minFillRate;\n    this.maxCapacity = this.minCapacity;\n  }\n  getCurrentTimeInSeconds() {\n    return Date.now() / 1000;\n  }\n  async getSendToken() {\n    return this.acquireTokenBucket(1);\n  }\n  async acquireTokenBucket(amount) {\n    if (!this.enabled) {\n      return;\n    }\n    this.refillTokenBucket();\n    if (amount > this.currentCapacity) {\n      const delay = (amount - this.currentCapacity) / this.fillRate * 1000;\n      await new Promise(resolve => DefaultRateLimiter.setTimeoutFn(resolve, delay));\n    }\n    this.currentCapacity = this.currentCapacity - amount;\n  }\n  refillTokenBucket() {\n    const timestamp = this.getCurrentTimeInSeconds();\n    if (!this.lastTimestamp) {\n      this.lastTimestamp = timestamp;\n      return;\n    }\n    const fillAmount = (timestamp - this.lastTimestamp) * this.fillRate;\n    this.currentCapacity = Math.min(this.maxCapacity, this.currentCapacity + fillAmount);\n    this.lastTimestamp = timestamp;\n  }\n  updateClientSendingRate(response) {\n    let calculatedRate;\n    this.updateMeasuredRate();\n    if (isThrottlingError(response)) {\n      const rateToUse = !this.enabled ? this.measuredTxRate : Math.min(this.measuredTxRate, this.fillRate);\n      this.lastMaxRate = rateToUse;\n      this.calculateTimeWindow();\n      this.lastThrottleTime = this.getCurrentTimeInSeconds();\n      calculatedRate = this.cubicThrottle(rateToUse);\n      this.enableTokenBucket();\n    } else {\n      this.calculateTimeWindow();\n      calculatedRate = this.cubicSuccess(this.getCurrentTimeInSeconds());\n    }\n    const newRate = Math.min(calculatedRate, 2 * this.measuredTxRate);\n    this.updateTokenBucketRate(newRate);\n  }\n  calculateTimeWindow() {\n    this.timeWindow = this.getPrecise(Math.pow(this.lastMaxRate * (1 - this.beta) / this.scaleConstant, 1 / 3));\n  }\n  cubicThrottle(rateToUse) {\n    return this.getPrecise(rateToUse * this.beta);\n  }\n  cubicSuccess(timestamp) {\n    return this.getPrecise(this.scaleConstant * Math.pow(timestamp - this.lastThrottleTime - this.timeWindow, 3) + this.lastMaxRate);\n  }\n  enableTokenBucket() {\n    this.enabled = true;\n  }\n  updateTokenBucketRate(newRate) {\n    this.refillTokenBucket();\n    this.fillRate = Math.max(newRate, this.minFillRate);\n    this.maxCapacity = Math.max(newRate, this.minCapacity);\n    this.currentCapacity = Math.min(this.currentCapacity, this.maxCapacity);\n  }\n  updateMeasuredRate() {\n    const t = this.getCurrentTimeInSeconds();\n    const timeBucket = Math.floor(t * 2) / 2;\n    this.requestCount++;\n    if (timeBucket > this.lastTxRateBucket) {\n      const currentRate = this.requestCount / (timeBucket - this.lastTxRateBucket);\n      this.measuredTxRate = this.getPrecise(currentRate * this.smooth + this.measuredTxRate * (1 - this.smooth));\n      this.requestCount = 0;\n      this.lastTxRateBucket = timeBucket;\n    }\n  }\n  getPrecise(num) {\n    return parseFloat(num.toFixed(8));\n  }\n}","map":{"version":3,"names":["isThrottlingError","DefaultRateLimiter","setTimeoutFn","setTimeout","beta","minCapacity","minFillRate","scaleConstant","smooth","currentCapacity","enabled","lastMaxRate","measuredTxRate","requestCount","fillRate","lastThrottleTime","lastTimestamp","lastTxRateBucket","maxCapacity","timeWindow","constructor","options","currentTimeInSeconds","getCurrentTimeInSeconds","Math","floor","Date","now","getSendToken","acquireTokenBucket","amount","refillTokenBucket","delay","Promise","resolve","timestamp","fillAmount","min","updateClientSendingRate","response","calculatedRate","updateMeasuredRate","rateToUse","calculateTimeWindow","cubicThrottle","enableTokenBucket","cubicSuccess","newRate","updateTokenBucketRate","getPrecise","pow","max","t","timeBucket","currentRate","num","parseFloat","toFixed"],"sources":["D:/ITechArt/react-lab-2025/application/node_modules/@aws-sdk/client-s3/node_modules/@smithy/util-retry/dist-es/DefaultRateLimiter.js"],"sourcesContent":["import { isThrottlingError } from \"@smithy/service-error-classification\";\nexport class DefaultRateLimiter {\n    static setTimeoutFn = setTimeout;\n    beta;\n    minCapacity;\n    minFillRate;\n    scaleConstant;\n    smooth;\n    currentCapacity = 0;\n    enabled = false;\n    lastMaxRate = 0;\n    measuredTxRate = 0;\n    requestCount = 0;\n    fillRate;\n    lastThrottleTime;\n    lastTimestamp = 0;\n    lastTxRateBucket;\n    maxCapacity;\n    timeWindow = 0;\n    constructor(options) {\n        this.beta = options?.beta ?? 0.7;\n        this.minCapacity = options?.minCapacity ?? 1;\n        this.minFillRate = options?.minFillRate ?? 0.5;\n        this.scaleConstant = options?.scaleConstant ?? 0.4;\n        this.smooth = options?.smooth ?? 0.8;\n        const currentTimeInSeconds = this.getCurrentTimeInSeconds();\n        this.lastThrottleTime = currentTimeInSeconds;\n        this.lastTxRateBucket = Math.floor(this.getCurrentTimeInSeconds());\n        this.fillRate = this.minFillRate;\n        this.maxCapacity = this.minCapacity;\n    }\n    getCurrentTimeInSeconds() {\n        return Date.now() / 1000;\n    }\n    async getSendToken() {\n        return this.acquireTokenBucket(1);\n    }\n    async acquireTokenBucket(amount) {\n        if (!this.enabled) {\n            return;\n        }\n        this.refillTokenBucket();\n        if (amount > this.currentCapacity) {\n            const delay = ((amount - this.currentCapacity) / this.fillRate) * 1000;\n            await new Promise((resolve) => DefaultRateLimiter.setTimeoutFn(resolve, delay));\n        }\n        this.currentCapacity = this.currentCapacity - amount;\n    }\n    refillTokenBucket() {\n        const timestamp = this.getCurrentTimeInSeconds();\n        if (!this.lastTimestamp) {\n            this.lastTimestamp = timestamp;\n            return;\n        }\n        const fillAmount = (timestamp - this.lastTimestamp) * this.fillRate;\n        this.currentCapacity = Math.min(this.maxCapacity, this.currentCapacity + fillAmount);\n        this.lastTimestamp = timestamp;\n    }\n    updateClientSendingRate(response) {\n        let calculatedRate;\n        this.updateMeasuredRate();\n        if (isThrottlingError(response)) {\n            const rateToUse = !this.enabled ? this.measuredTxRate : Math.min(this.measuredTxRate, this.fillRate);\n            this.lastMaxRate = rateToUse;\n            this.calculateTimeWindow();\n            this.lastThrottleTime = this.getCurrentTimeInSeconds();\n            calculatedRate = this.cubicThrottle(rateToUse);\n            this.enableTokenBucket();\n        }\n        else {\n            this.calculateTimeWindow();\n            calculatedRate = this.cubicSuccess(this.getCurrentTimeInSeconds());\n        }\n        const newRate = Math.min(calculatedRate, 2 * this.measuredTxRate);\n        this.updateTokenBucketRate(newRate);\n    }\n    calculateTimeWindow() {\n        this.timeWindow = this.getPrecise(Math.pow((this.lastMaxRate * (1 - this.beta)) / this.scaleConstant, 1 / 3));\n    }\n    cubicThrottle(rateToUse) {\n        return this.getPrecise(rateToUse * this.beta);\n    }\n    cubicSuccess(timestamp) {\n        return this.getPrecise(this.scaleConstant * Math.pow(timestamp - this.lastThrottleTime - this.timeWindow, 3) + this.lastMaxRate);\n    }\n    enableTokenBucket() {\n        this.enabled = true;\n    }\n    updateTokenBucketRate(newRate) {\n        this.refillTokenBucket();\n        this.fillRate = Math.max(newRate, this.minFillRate);\n        this.maxCapacity = Math.max(newRate, this.minCapacity);\n        this.currentCapacity = Math.min(this.currentCapacity, this.maxCapacity);\n    }\n    updateMeasuredRate() {\n        const t = this.getCurrentTimeInSeconds();\n        const timeBucket = Math.floor(t * 2) / 2;\n        this.requestCount++;\n        if (timeBucket > this.lastTxRateBucket) {\n            const currentRate = this.requestCount / (timeBucket - this.lastTxRateBucket);\n            this.measuredTxRate = this.getPrecise(currentRate * this.smooth + this.measuredTxRate * (1 - this.smooth));\n            this.requestCount = 0;\n            this.lastTxRateBucket = timeBucket;\n        }\n    }\n    getPrecise(num) {\n        return parseFloat(num.toFixed(8));\n    }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}