{"ast":null,"code":"import { parseXML } from \"@aws-sdk/xml-builder\";\nimport { FromStringShapeDeserializer } from \"@smithy/core/protocols\";\nimport { NormalizedSchema } from \"@smithy/core/schema\";\nimport { getValueFromTextNode } from \"@smithy/smithy-client\";\nimport { toUtf8 } from \"@smithy/util-utf8\";\nimport { SerdeContextConfig } from \"../ConfigurableSerdeContext\";\nexport class XmlShapeDeserializer extends SerdeContextConfig {\n  settings;\n  stringDeserializer;\n  constructor(settings) {\n    super();\n    this.settings = settings;\n    this.stringDeserializer = new FromStringShapeDeserializer(settings);\n  }\n  setSerdeContext(serdeContext) {\n    this.serdeContext = serdeContext;\n    this.stringDeserializer.setSerdeContext(serdeContext);\n  }\n  read(schema, bytes, key) {\n    const ns = NormalizedSchema.of(schema);\n    const memberSchemas = ns.getMemberSchemas();\n    const isEventPayload = ns.isStructSchema() && ns.isMemberSchema() && !!Object.values(memberSchemas).find(memberNs => {\n      return !!memberNs.getMemberTraits().eventPayload;\n    });\n    if (isEventPayload) {\n      const output = {};\n      const memberName = Object.keys(memberSchemas)[0];\n      const eventMemberSchema = memberSchemas[memberName];\n      if (eventMemberSchema.isBlobSchema()) {\n        output[memberName] = bytes;\n      } else {\n        output[memberName] = this.read(memberSchemas[memberName], bytes);\n      }\n      return output;\n    }\n    const xmlString = (this.serdeContext?.utf8Encoder ?? toUtf8)(bytes);\n    const parsedObject = this.parseXml(xmlString);\n    return this.readSchema(schema, key ? parsedObject[key] : parsedObject);\n  }\n  readSchema(_schema, value) {\n    const ns = NormalizedSchema.of(_schema);\n    if (ns.isUnitSchema()) {\n      return;\n    }\n    const traits = ns.getMergedTraits();\n    if (ns.isListSchema() && !Array.isArray(value)) {\n      return this.readSchema(ns, [value]);\n    }\n    if (value == null) {\n      return value;\n    }\n    if (typeof value === \"object\") {\n      const sparse = !!traits.sparse;\n      const flat = !!traits.xmlFlattened;\n      if (ns.isListSchema()) {\n        const listValue = ns.getValueSchema();\n        const buffer = [];\n        const sourceKey = listValue.getMergedTraits().xmlName ?? \"member\";\n        const source = flat ? value : (value[0] ?? value)[sourceKey];\n        const sourceArray = Array.isArray(source) ? source : [source];\n        for (const v of sourceArray) {\n          if (v != null || sparse) {\n            buffer.push(this.readSchema(listValue, v));\n          }\n        }\n        return buffer;\n      }\n      const buffer = {};\n      if (ns.isMapSchema()) {\n        const keyNs = ns.getKeySchema();\n        const memberNs = ns.getValueSchema();\n        let entries;\n        if (flat) {\n          entries = Array.isArray(value) ? value : [value];\n        } else {\n          entries = Array.isArray(value.entry) ? value.entry : [value.entry];\n        }\n        const keyProperty = keyNs.getMergedTraits().xmlName ?? \"key\";\n        const valueProperty = memberNs.getMergedTraits().xmlName ?? \"value\";\n        for (const entry of entries) {\n          const key = entry[keyProperty];\n          const value = entry[valueProperty];\n          if (value != null || sparse) {\n            buffer[key] = this.readSchema(memberNs, value);\n          }\n        }\n        return buffer;\n      }\n      if (ns.isStructSchema()) {\n        for (const [memberName, memberSchema] of ns.structIterator()) {\n          const memberTraits = memberSchema.getMergedTraits();\n          const xmlObjectKey = !memberTraits.httpPayload ? memberSchema.getMemberTraits().xmlName ?? memberName : memberTraits.xmlName ?? memberSchema.getName();\n          if (value[xmlObjectKey] != null) {\n            buffer[memberName] = this.readSchema(memberSchema, value[xmlObjectKey]);\n          }\n        }\n        return buffer;\n      }\n      if (ns.isDocumentSchema()) {\n        return value;\n      }\n      throw new Error(`@aws-sdk/core/protocols - xml deserializer unhandled schema type for ${ns.getName(true)}`);\n    }\n    if (ns.isListSchema()) {\n      return [];\n    }\n    if (ns.isMapSchema() || ns.isStructSchema()) {\n      return {};\n    }\n    return this.stringDeserializer.read(ns, value);\n  }\n  parseXml(xml) {\n    if (xml.length) {\n      let parsedObj;\n      try {\n        parsedObj = parseXML(xml);\n      } catch (e) {\n        if (e && typeof e === \"object\") {\n          Object.defineProperty(e, \"$responseBodyText\", {\n            value: xml\n          });\n        }\n        throw e;\n      }\n      const textNodeName = \"#text\";\n      const key = Object.keys(parsedObj)[0];\n      const parsedObjToReturn = parsedObj[key];\n      if (parsedObjToReturn[textNodeName]) {\n        parsedObjToReturn[key] = parsedObjToReturn[textNodeName];\n        delete parsedObjToReturn[textNodeName];\n      }\n      return getValueFromTextNode(parsedObjToReturn);\n    }\n    return {};\n  }\n}","map":{"version":3,"names":["parseXML","FromStringShapeDeserializer","NormalizedSchema","getValueFromTextNode","toUtf8","SerdeContextConfig","XmlShapeDeserializer","settings","stringDeserializer","constructor","setSerdeContext","serdeContext","read","schema","bytes","key","ns","of","memberSchemas","getMemberSchemas","isEventPayload","isStructSchema","isMemberSchema","Object","values","find","memberNs","getMemberTraits","eventPayload","output","memberName","keys","eventMemberSchema","isBlobSchema","xmlString","utf8Encoder","parsedObject","parseXml","readSchema","_schema","value","isUnitSchema","traits","getMergedTraits","isListSchema","Array","isArray","sparse","flat","xmlFlattened","listValue","getValueSchema","buffer","sourceKey","xmlName","source","sourceArray","v","push","isMapSchema","keyNs","getKeySchema","entries","entry","keyProperty","valueProperty","memberSchema","structIterator","memberTraits","xmlObjectKey","httpPayload","getName","isDocumentSchema","Error","xml","length","parsedObj","e","defineProperty","textNodeName","parsedObjToReturn"],"sources":["D:/ITechArt/react-lab-2025/application/node_modules/@aws-sdk/middleware-flexible-checksums/node_modules/@aws-sdk/core/dist-es/submodules/protocols/xml/XmlShapeDeserializer.js"],"sourcesContent":["import { parseXML } from \"@aws-sdk/xml-builder\";\nimport { FromStringShapeDeserializer } from \"@smithy/core/protocols\";\nimport { NormalizedSchema } from \"@smithy/core/schema\";\nimport { getValueFromTextNode } from \"@smithy/smithy-client\";\nimport { toUtf8 } from \"@smithy/util-utf8\";\nimport { SerdeContextConfig } from \"../ConfigurableSerdeContext\";\nexport class XmlShapeDeserializer extends SerdeContextConfig {\n    settings;\n    stringDeserializer;\n    constructor(settings) {\n        super();\n        this.settings = settings;\n        this.stringDeserializer = new FromStringShapeDeserializer(settings);\n    }\n    setSerdeContext(serdeContext) {\n        this.serdeContext = serdeContext;\n        this.stringDeserializer.setSerdeContext(serdeContext);\n    }\n    read(schema, bytes, key) {\n        const ns = NormalizedSchema.of(schema);\n        const memberSchemas = ns.getMemberSchemas();\n        const isEventPayload = ns.isStructSchema() &&\n            ns.isMemberSchema() &&\n            !!Object.values(memberSchemas).find((memberNs) => {\n                return !!memberNs.getMemberTraits().eventPayload;\n            });\n        if (isEventPayload) {\n            const output = {};\n            const memberName = Object.keys(memberSchemas)[0];\n            const eventMemberSchema = memberSchemas[memberName];\n            if (eventMemberSchema.isBlobSchema()) {\n                output[memberName] = bytes;\n            }\n            else {\n                output[memberName] = this.read(memberSchemas[memberName], bytes);\n            }\n            return output;\n        }\n        const xmlString = (this.serdeContext?.utf8Encoder ?? toUtf8)(bytes);\n        const parsedObject = this.parseXml(xmlString);\n        return this.readSchema(schema, key ? parsedObject[key] : parsedObject);\n    }\n    readSchema(_schema, value) {\n        const ns = NormalizedSchema.of(_schema);\n        if (ns.isUnitSchema()) {\n            return;\n        }\n        const traits = ns.getMergedTraits();\n        if (ns.isListSchema() && !Array.isArray(value)) {\n            return this.readSchema(ns, [value]);\n        }\n        if (value == null) {\n            return value;\n        }\n        if (typeof value === \"object\") {\n            const sparse = !!traits.sparse;\n            const flat = !!traits.xmlFlattened;\n            if (ns.isListSchema()) {\n                const listValue = ns.getValueSchema();\n                const buffer = [];\n                const sourceKey = listValue.getMergedTraits().xmlName ?? \"member\";\n                const source = flat ? value : (value[0] ?? value)[sourceKey];\n                const sourceArray = Array.isArray(source) ? source : [source];\n                for (const v of sourceArray) {\n                    if (v != null || sparse) {\n                        buffer.push(this.readSchema(listValue, v));\n                    }\n                }\n                return buffer;\n            }\n            const buffer = {};\n            if (ns.isMapSchema()) {\n                const keyNs = ns.getKeySchema();\n                const memberNs = ns.getValueSchema();\n                let entries;\n                if (flat) {\n                    entries = Array.isArray(value) ? value : [value];\n                }\n                else {\n                    entries = Array.isArray(value.entry) ? value.entry : [value.entry];\n                }\n                const keyProperty = keyNs.getMergedTraits().xmlName ?? \"key\";\n                const valueProperty = memberNs.getMergedTraits().xmlName ?? \"value\";\n                for (const entry of entries) {\n                    const key = entry[keyProperty];\n                    const value = entry[valueProperty];\n                    if (value != null || sparse) {\n                        buffer[key] = this.readSchema(memberNs, value);\n                    }\n                }\n                return buffer;\n            }\n            if (ns.isStructSchema()) {\n                for (const [memberName, memberSchema] of ns.structIterator()) {\n                    const memberTraits = memberSchema.getMergedTraits();\n                    const xmlObjectKey = !memberTraits.httpPayload\n                        ? memberSchema.getMemberTraits().xmlName ?? memberName\n                        : memberTraits.xmlName ?? memberSchema.getName();\n                    if (value[xmlObjectKey] != null) {\n                        buffer[memberName] = this.readSchema(memberSchema, value[xmlObjectKey]);\n                    }\n                }\n                return buffer;\n            }\n            if (ns.isDocumentSchema()) {\n                return value;\n            }\n            throw new Error(`@aws-sdk/core/protocols - xml deserializer unhandled schema type for ${ns.getName(true)}`);\n        }\n        if (ns.isListSchema()) {\n            return [];\n        }\n        if (ns.isMapSchema() || ns.isStructSchema()) {\n            return {};\n        }\n        return this.stringDeserializer.read(ns, value);\n    }\n    parseXml(xml) {\n        if (xml.length) {\n            let parsedObj;\n            try {\n                parsedObj = parseXML(xml);\n            }\n            catch (e) {\n                if (e && typeof e === \"object\") {\n                    Object.defineProperty(e, \"$responseBodyText\", {\n                        value: xml,\n                    });\n                }\n                throw e;\n            }\n            const textNodeName = \"#text\";\n            const key = Object.keys(parsedObj)[0];\n            const parsedObjToReturn = parsedObj[key];\n            if (parsedObjToReturn[textNodeName]) {\n                parsedObjToReturn[key] = parsedObjToReturn[textNodeName];\n                delete parsedObjToReturn[textNodeName];\n            }\n            return getValueFromTextNode(parsedObjToReturn);\n        }\n        return {};\n    }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}