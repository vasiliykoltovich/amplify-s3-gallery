{"ast":null,"code":"import { SignatureV4MultiRegion } from \"@aws-sdk/signature-v4-multi-region\";\nimport { SHA256_HEADER, UNSIGNED_PAYLOAD } from \"./constants\";\nexport class S3RequestPresigner {\n  signer;\n  constructor(options) {\n    const resolvedOptions = {\n      service: options.signingName || options.service || \"s3\",\n      uriEscapePath: options.uriEscapePath || false,\n      applyChecksum: options.applyChecksum || false,\n      ...options\n    };\n    this.signer = new SignatureV4MultiRegion(resolvedOptions);\n  }\n  presign(requestToSign, {\n    unsignableHeaders = new Set(),\n    hoistableHeaders = new Set(),\n    unhoistableHeaders = new Set(),\n    ...options\n  } = {}) {\n    this.prepareRequest(requestToSign, {\n      unsignableHeaders,\n      unhoistableHeaders,\n      hoistableHeaders\n    });\n    return this.signer.presign(requestToSign, {\n      expiresIn: 900,\n      unsignableHeaders,\n      unhoistableHeaders,\n      ...options\n    });\n  }\n  presignWithCredentials(requestToSign, credentials, {\n    unsignableHeaders = new Set(),\n    hoistableHeaders = new Set(),\n    unhoistableHeaders = new Set(),\n    ...options\n  } = {}) {\n    this.prepareRequest(requestToSign, {\n      unsignableHeaders,\n      unhoistableHeaders,\n      hoistableHeaders\n    });\n    return this.signer.presignWithCredentials(requestToSign, credentials, {\n      expiresIn: 900,\n      unsignableHeaders,\n      unhoistableHeaders,\n      ...options\n    });\n  }\n  prepareRequest(requestToSign, {\n    unsignableHeaders = new Set(),\n    unhoistableHeaders = new Set(),\n    hoistableHeaders = new Set()\n  } = {}) {\n    unsignableHeaders.add(\"content-type\");\n    Object.keys(requestToSign.headers).map(header => header.toLowerCase()).filter(header => header.startsWith(\"x-amz-server-side-encryption\")).forEach(header => {\n      if (!hoistableHeaders.has(header)) {\n        unhoistableHeaders.add(header);\n      }\n    });\n    requestToSign.headers[SHA256_HEADER] = UNSIGNED_PAYLOAD;\n    const currentHostHeader = requestToSign.headers.host;\n    const port = requestToSign.port;\n    const expectedHostHeader = `${requestToSign.hostname}${requestToSign.port != null ? \":\" + port : \"\"}`;\n    if (!currentHostHeader || currentHostHeader === requestToSign.hostname && requestToSign.port != null) {\n      requestToSign.headers.host = expectedHostHeader;\n    }\n  }\n}","map":{"version":3,"names":["SignatureV4MultiRegion","SHA256_HEADER","UNSIGNED_PAYLOAD","S3RequestPresigner","signer","constructor","options","resolvedOptions","service","signingName","uriEscapePath","applyChecksum","presign","requestToSign","unsignableHeaders","Set","hoistableHeaders","unhoistableHeaders","prepareRequest","expiresIn","presignWithCredentials","credentials","add","Object","keys","headers","map","header","toLowerCase","filter","startsWith","forEach","has","currentHostHeader","host","port","expectedHostHeader","hostname"],"sources":["D:/ITechArt/react-lab-2025/application/amplify-s3-gallery/node_modules/@aws-sdk/s3-request-presigner/dist-es/presigner.js"],"sourcesContent":["import { SignatureV4MultiRegion } from \"@aws-sdk/signature-v4-multi-region\";\nimport { SHA256_HEADER, UNSIGNED_PAYLOAD } from \"./constants\";\nexport class S3RequestPresigner {\n    signer;\n    constructor(options) {\n        const resolvedOptions = {\n            service: options.signingName || options.service || \"s3\",\n            uriEscapePath: options.uriEscapePath || false,\n            applyChecksum: options.applyChecksum || false,\n            ...options,\n        };\n        this.signer = new SignatureV4MultiRegion(resolvedOptions);\n    }\n    presign(requestToSign, { unsignableHeaders = new Set(), hoistableHeaders = new Set(), unhoistableHeaders = new Set(), ...options } = {}) {\n        this.prepareRequest(requestToSign, {\n            unsignableHeaders,\n            unhoistableHeaders,\n            hoistableHeaders,\n        });\n        return this.signer.presign(requestToSign, {\n            expiresIn: 900,\n            unsignableHeaders,\n            unhoistableHeaders,\n            ...options,\n        });\n    }\n    presignWithCredentials(requestToSign, credentials, { unsignableHeaders = new Set(), hoistableHeaders = new Set(), unhoistableHeaders = new Set(), ...options } = {}) {\n        this.prepareRequest(requestToSign, {\n            unsignableHeaders,\n            unhoistableHeaders,\n            hoistableHeaders,\n        });\n        return this.signer.presignWithCredentials(requestToSign, credentials, {\n            expiresIn: 900,\n            unsignableHeaders,\n            unhoistableHeaders,\n            ...options,\n        });\n    }\n    prepareRequest(requestToSign, { unsignableHeaders = new Set(), unhoistableHeaders = new Set(), hoistableHeaders = new Set(), } = {}) {\n        unsignableHeaders.add(\"content-type\");\n        Object.keys(requestToSign.headers)\n            .map((header) => header.toLowerCase())\n            .filter((header) => header.startsWith(\"x-amz-server-side-encryption\"))\n            .forEach((header) => {\n            if (!hoistableHeaders.has(header)) {\n                unhoistableHeaders.add(header);\n            }\n        });\n        requestToSign.headers[SHA256_HEADER] = UNSIGNED_PAYLOAD;\n        const currentHostHeader = requestToSign.headers.host;\n        const port = requestToSign.port;\n        const expectedHostHeader = `${requestToSign.hostname}${requestToSign.port != null ? \":\" + port : \"\"}`;\n        if (!currentHostHeader || (currentHostHeader === requestToSign.hostname && requestToSign.port != null)) {\n            requestToSign.headers.host = expectedHostHeader;\n        }\n    }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}