{"ast":null,"code":"import { collectBody } from \"@smithy/core/protocols\";\nimport { HttpRequest as __HttpRequest } from \"@smithy/protocol-http\";\nimport { calculateBodyLength } from \"@smithy/util-body-length-browser\";\nimport { cbor } from \"./cbor\";\nimport { tag } from \"./cbor-types\";\nexport const parseCborBody = (streamBody, context) => {\n  return collectBody(streamBody, context).then(async bytes => {\n    if (bytes.length) {\n      try {\n        return cbor.deserialize(bytes);\n      } catch (e) {\n        Object.defineProperty(e, \"$responseBodyText\", {\n          value: context.utf8Encoder(bytes)\n        });\n        throw e;\n      }\n    }\n    return {};\n  });\n};\nexport const dateToTag = date => {\n  return tag({\n    tag: 1,\n    value: date.getTime() / 1000\n  });\n};\nexport const parseCborErrorBody = async (errorBody, context) => {\n  const value = await parseCborBody(errorBody, context);\n  value.message = value.message ?? value.Message;\n  return value;\n};\nexport const loadSmithyRpcV2CborErrorCode = (output, data) => {\n  const sanitizeErrorCode = rawValue => {\n    let cleanValue = rawValue;\n    if (typeof cleanValue === \"number\") {\n      cleanValue = cleanValue.toString();\n    }\n    if (cleanValue.indexOf(\",\") >= 0) {\n      cleanValue = cleanValue.split(\",\")[0];\n    }\n    if (cleanValue.indexOf(\":\") >= 0) {\n      cleanValue = cleanValue.split(\":\")[0];\n    }\n    if (cleanValue.indexOf(\"#\") >= 0) {\n      cleanValue = cleanValue.split(\"#\")[1];\n    }\n    return cleanValue;\n  };\n  if (data[\"__type\"] !== undefined) {\n    return sanitizeErrorCode(data[\"__type\"]);\n  }\n  const codeKey = Object.keys(data).find(key => key.toLowerCase() === \"code\");\n  if (codeKey && data[codeKey] !== undefined) {\n    return sanitizeErrorCode(data[codeKey]);\n  }\n};\nexport const checkCborResponse = response => {\n  if (String(response.headers[\"smithy-protocol\"]).toLowerCase() !== \"rpc-v2-cbor\") {\n    throw new Error(\"Malformed RPCv2 CBOR response, status: \" + response.statusCode);\n  }\n};\nexport const buildHttpRpcRequest = async (context, headers, path, resolvedHostname, body) => {\n  const {\n    hostname,\n    protocol = \"https\",\n    port,\n    path: basePath\n  } = await context.endpoint();\n  const contents = {\n    protocol,\n    hostname,\n    port,\n    method: \"POST\",\n    path: basePath.endsWith(\"/\") ? basePath.slice(0, -1) + path : basePath + path,\n    headers: {\n      ...headers\n    }\n  };\n  if (resolvedHostname !== undefined) {\n    contents.hostname = resolvedHostname;\n  }\n  if (body !== undefined) {\n    contents.body = body;\n    try {\n      contents.headers[\"content-length\"] = String(calculateBodyLength(body));\n    } catch (e) {}\n  }\n  return new __HttpRequest(contents);\n};","map":{"version":3,"names":["collectBody","HttpRequest","__HttpRequest","calculateBodyLength","cbor","tag","parseCborBody","streamBody","context","then","bytes","length","deserialize","e","Object","defineProperty","value","utf8Encoder","dateToTag","date","getTime","parseCborErrorBody","errorBody","message","Message","loadSmithyRpcV2CborErrorCode","output","data","sanitizeErrorCode","rawValue","cleanValue","toString","indexOf","split","undefined","codeKey","keys","find","key","toLowerCase","checkCborResponse","response","String","headers","Error","statusCode","buildHttpRpcRequest","path","resolvedHostname","body","hostname","protocol","port","basePath","endpoint","contents","method","endsWith","slice"],"sources":["d:/ITechArt/react-lab-2025/application/node_modules/@aws-sdk/middleware-sdk-s3/node_modules/@smithy/core/dist-es/submodules/cbor/parseCborBody.js"],"sourcesContent":["import { collectBody } from \"@smithy/core/protocols\";\nimport { HttpRequest as __HttpRequest } from \"@smithy/protocol-http\";\nimport { calculateBodyLength } from \"@smithy/util-body-length-browser\";\nimport { cbor } from \"./cbor\";\nimport { tag } from \"./cbor-types\";\nexport const parseCborBody = (streamBody, context) => {\n    return collectBody(streamBody, context).then(async (bytes) => {\n        if (bytes.length) {\n            try {\n                return cbor.deserialize(bytes);\n            }\n            catch (e) {\n                Object.defineProperty(e, \"$responseBodyText\", {\n                    value: context.utf8Encoder(bytes),\n                });\n                throw e;\n            }\n        }\n        return {};\n    });\n};\nexport const dateToTag = (date) => {\n    return tag({\n        tag: 1,\n        value: date.getTime() / 1000,\n    });\n};\nexport const parseCborErrorBody = async (errorBody, context) => {\n    const value = await parseCborBody(errorBody, context);\n    value.message = value.message ?? value.Message;\n    return value;\n};\nexport const loadSmithyRpcV2CborErrorCode = (output, data) => {\n    const sanitizeErrorCode = (rawValue) => {\n        let cleanValue = rawValue;\n        if (typeof cleanValue === \"number\") {\n            cleanValue = cleanValue.toString();\n        }\n        if (cleanValue.indexOf(\",\") >= 0) {\n            cleanValue = cleanValue.split(\",\")[0];\n        }\n        if (cleanValue.indexOf(\":\") >= 0) {\n            cleanValue = cleanValue.split(\":\")[0];\n        }\n        if (cleanValue.indexOf(\"#\") >= 0) {\n            cleanValue = cleanValue.split(\"#\")[1];\n        }\n        return cleanValue;\n    };\n    if (data[\"__type\"] !== undefined) {\n        return sanitizeErrorCode(data[\"__type\"]);\n    }\n    const codeKey = Object.keys(data).find((key) => key.toLowerCase() === \"code\");\n    if (codeKey && data[codeKey] !== undefined) {\n        return sanitizeErrorCode(data[codeKey]);\n    }\n};\nexport const checkCborResponse = (response) => {\n    if (String(response.headers[\"smithy-protocol\"]).toLowerCase() !== \"rpc-v2-cbor\") {\n        throw new Error(\"Malformed RPCv2 CBOR response, status: \" + response.statusCode);\n    }\n};\nexport const buildHttpRpcRequest = async (context, headers, path, resolvedHostname, body) => {\n    const { hostname, protocol = \"https\", port, path: basePath } = await context.endpoint();\n    const contents = {\n        protocol,\n        hostname,\n        port,\n        method: \"POST\",\n        path: basePath.endsWith(\"/\") ? basePath.slice(0, -1) + path : basePath + path,\n        headers: {\n            ...headers,\n        },\n    };\n    if (resolvedHostname !== undefined) {\n        contents.hostname = resolvedHostname;\n    }\n    if (body !== undefined) {\n        contents.body = body;\n        try {\n            contents.headers[\"content-length\"] = String(calculateBodyLength(body));\n        }\n        catch (e) { }\n    }\n    return new __HttpRequest(contents);\n};\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}