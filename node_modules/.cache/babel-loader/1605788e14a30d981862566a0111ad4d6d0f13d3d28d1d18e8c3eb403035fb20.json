{"ast":null,"code":"import { fromUtf8, toUtf8 } from \"@smithy/util-utf8\";\nexport class EventStreamSerde {\n  marshaller;\n  serializer;\n  deserializer;\n  serdeContext;\n  defaultContentType;\n  constructor({\n    marshaller,\n    serializer,\n    deserializer,\n    serdeContext,\n    defaultContentType\n  }) {\n    this.marshaller = marshaller;\n    this.serializer = serializer;\n    this.deserializer = deserializer;\n    this.serdeContext = serdeContext;\n    this.defaultContentType = defaultContentType;\n  }\n  async serializeEventStream({\n    eventStream,\n    requestSchema,\n    initialRequest\n  }) {\n    const marshaller = this.marshaller;\n    const eventStreamMember = requestSchema.getEventStreamMember();\n    const unionSchema = requestSchema.getMemberSchema(eventStreamMember);\n    const serializer = this.serializer;\n    const defaultContentType = this.defaultContentType;\n    const initialRequestMarker = Symbol(\"initialRequestMarker\");\n    const eventStreamIterable = {\n      async *[Symbol.asyncIterator]() {\n        if (initialRequest) {\n          const headers = {\n            \":event-type\": {\n              type: \"string\",\n              value: \"initial-request\"\n            },\n            \":message-type\": {\n              type: \"string\",\n              value: \"event\"\n            },\n            \":content-type\": {\n              type: \"string\",\n              value: defaultContentType\n            }\n          };\n          serializer.write(requestSchema, initialRequest);\n          const body = serializer.flush();\n          yield {\n            [initialRequestMarker]: true,\n            headers,\n            body\n          };\n        }\n        for await (const page of eventStream) {\n          yield page;\n        }\n      }\n    };\n    return marshaller.serialize(eventStreamIterable, event => {\n      if (event[initialRequestMarker]) {\n        return {\n          headers: event.headers,\n          body: event.body\n        };\n      }\n      const unionMember = Object.keys(event).find(key => {\n        return key !== \"__type\";\n      }) ?? \"\";\n      const {\n        additionalHeaders,\n        body,\n        eventType,\n        explicitPayloadContentType\n      } = this.writeEventBody(unionMember, unionSchema, event);\n      const headers = {\n        \":event-type\": {\n          type: \"string\",\n          value: eventType\n        },\n        \":message-type\": {\n          type: \"string\",\n          value: \"event\"\n        },\n        \":content-type\": {\n          type: \"string\",\n          value: explicitPayloadContentType ?? defaultContentType\n        },\n        ...additionalHeaders\n      };\n      return {\n        headers,\n        body\n      };\n    });\n  }\n  async deserializeEventStream({\n    response,\n    responseSchema,\n    initialResponseContainer\n  }) {\n    const marshaller = this.marshaller;\n    const eventStreamMember = responseSchema.getEventStreamMember();\n    const unionSchema = responseSchema.getMemberSchema(eventStreamMember);\n    const memberSchemas = unionSchema.getMemberSchemas();\n    const initialResponseMarker = Symbol(\"initialResponseMarker\");\n    const asyncIterable = marshaller.deserialize(response.body, async event => {\n      const unionMember = Object.keys(event).find(key => {\n        return key !== \"__type\";\n      }) ?? \"\";\n      const body = event[unionMember].body;\n      if (unionMember === \"initial-response\") {\n        const dataObject = await this.deserializer.read(responseSchema, body);\n        delete dataObject[eventStreamMember];\n        return {\n          [initialResponseMarker]: true,\n          ...dataObject\n        };\n      } else if (unionMember in memberSchemas) {\n        const eventStreamSchema = memberSchemas[unionMember];\n        if (eventStreamSchema.isStructSchema()) {\n          const out = {};\n          let hasBindings = false;\n          for (const [name, member] of eventStreamSchema.structIterator()) {\n            const {\n              eventHeader,\n              eventPayload\n            } = member.getMergedTraits();\n            hasBindings = hasBindings || Boolean(eventHeader || eventPayload);\n            if (eventPayload) {\n              if (member.isBlobSchema()) {\n                out[name] = body;\n              } else if (member.isStringSchema()) {\n                out[name] = (this.serdeContext?.utf8Encoder ?? toUtf8)(body);\n              } else if (member.isStructSchema()) {\n                out[name] = await this.deserializer.read(member, body);\n              }\n            } else if (eventHeader) {\n              const value = event[unionMember].headers[name]?.value;\n              if (value != null) {\n                if (member.isNumericSchema()) {\n                  if (value && typeof value === \"object\" && \"bytes\" in value) {\n                    out[name] = BigInt(value.toString());\n                  } else {\n                    out[name] = Number(value);\n                  }\n                } else {\n                  out[name] = value;\n                }\n              }\n            }\n          }\n          if (hasBindings) {\n            return {\n              [unionMember]: out\n            };\n          }\n        }\n        return {\n          [unionMember]: await this.deserializer.read(eventStreamSchema, body)\n        };\n      } else {\n        return {\n          $unknown: event\n        };\n      }\n    });\n    const asyncIterator = asyncIterable[Symbol.asyncIterator]();\n    const firstEvent = await asyncIterator.next();\n    if (firstEvent.done) {\n      return asyncIterable;\n    }\n    if (firstEvent.value?.[initialResponseMarker]) {\n      if (!responseSchema) {\n        throw new Error(\"@smithy::core/protocols - initial-response event encountered in event stream but no response schema given.\");\n      }\n      for (const [key, value] of Object.entries(firstEvent.value)) {\n        initialResponseContainer[key] = value;\n      }\n    }\n    return {\n      async *[Symbol.asyncIterator]() {\n        if (!firstEvent?.value?.[initialResponseMarker]) {\n          yield firstEvent.value;\n        }\n        while (true) {\n          const {\n            done,\n            value\n          } = await asyncIterator.next();\n          if (done) {\n            break;\n          }\n          yield value;\n        }\n      }\n    };\n  }\n  writeEventBody(unionMember, unionSchema, event) {\n    const serializer = this.serializer;\n    let eventType = unionMember;\n    let explicitPayloadMember = null;\n    let explicitPayloadContentType;\n    const isKnownSchema = (() => {\n      const struct = unionSchema.getSchema();\n      return struct[4].includes(unionMember);\n    })();\n    const additionalHeaders = {};\n    if (!isKnownSchema) {\n      const [type, value] = event[unionMember];\n      eventType = type;\n      serializer.write(15, value);\n    } else {\n      const eventSchema = unionSchema.getMemberSchema(unionMember);\n      if (eventSchema.isStructSchema()) {\n        for (const [memberName, memberSchema] of eventSchema.structIterator()) {\n          const {\n            eventHeader,\n            eventPayload\n          } = memberSchema.getMergedTraits();\n          if (eventPayload) {\n            explicitPayloadMember = memberName;\n            break;\n          } else if (eventHeader) {\n            const value = event[unionMember][memberName];\n            let type = \"binary\";\n            if (memberSchema.isNumericSchema()) {\n              if ((-2) ** 31 <= value && value <= 2 ** 31 - 1) {\n                type = \"integer\";\n              } else {\n                type = \"long\";\n              }\n            } else if (memberSchema.isTimestampSchema()) {\n              type = \"timestamp\";\n            } else if (memberSchema.isStringSchema()) {\n              type = \"string\";\n            } else if (memberSchema.isBooleanSchema()) {\n              type = \"boolean\";\n            }\n            if (value != null) {\n              additionalHeaders[memberName] = {\n                type,\n                value\n              };\n              delete event[unionMember][memberName];\n            }\n          }\n        }\n        if (explicitPayloadMember !== null) {\n          const payloadSchema = eventSchema.getMemberSchema(explicitPayloadMember);\n          if (payloadSchema.isBlobSchema()) {\n            explicitPayloadContentType = \"application/octet-stream\";\n          } else if (payloadSchema.isStringSchema()) {\n            explicitPayloadContentType = \"text/plain\";\n          }\n          serializer.write(payloadSchema, event[unionMember][explicitPayloadMember]);\n        } else {\n          serializer.write(eventSchema, event[unionMember]);\n        }\n      } else {\n        throw new Error(\"@smithy/core/event-streams - non-struct member not supported in event stream union.\");\n      }\n    }\n    const messageSerialization = serializer.flush();\n    const body = typeof messageSerialization === \"string\" ? (this.serdeContext?.utf8Decoder ?? fromUtf8)(messageSerialization) : messageSerialization;\n    return {\n      body,\n      eventType,\n      explicitPayloadContentType,\n      additionalHeaders\n    };\n  }\n}","map":{"version":3,"names":["fromUtf8","toUtf8","EventStreamSerde","marshaller","serializer","deserializer","serdeContext","defaultContentType","constructor","serializeEventStream","eventStream","requestSchema","initialRequest","eventStreamMember","getEventStreamMember","unionSchema","getMemberSchema","initialRequestMarker","Symbol","eventStreamIterable","asyncIterator","headers","type","value","write","body","flush","page","serialize","event","unionMember","Object","keys","find","key","additionalHeaders","eventType","explicitPayloadContentType","writeEventBody","deserializeEventStream","response","responseSchema","initialResponseContainer","memberSchemas","getMemberSchemas","initialResponseMarker","asyncIterable","deserialize","dataObject","read","eventStreamSchema","isStructSchema","out","hasBindings","name","member","structIterator","eventHeader","eventPayload","getMergedTraits","Boolean","isBlobSchema","isStringSchema","utf8Encoder","isNumericSchema","BigInt","toString","Number","$unknown","firstEvent","next","done","Error","entries","explicitPayloadMember","isKnownSchema","struct","getSchema","includes","eventSchema","memberName","memberSchema","isTimestampSchema","isBooleanSchema","payloadSchema","messageSerialization","utf8Decoder"],"sources":["d:/ITechArt/react-lab-2025/application/node_modules/@aws-sdk/s3-request-presigner/node_modules/@smithy/core/dist-es/submodules/event-streams/EventStreamSerde.js"],"sourcesContent":["import { fromUtf8, toUtf8 } from \"@smithy/util-utf8\";\nexport class EventStreamSerde {\n    marshaller;\n    serializer;\n    deserializer;\n    serdeContext;\n    defaultContentType;\n    constructor({ marshaller, serializer, deserializer, serdeContext, defaultContentType, }) {\n        this.marshaller = marshaller;\n        this.serializer = serializer;\n        this.deserializer = deserializer;\n        this.serdeContext = serdeContext;\n        this.defaultContentType = defaultContentType;\n    }\n    async serializeEventStream({ eventStream, requestSchema, initialRequest, }) {\n        const marshaller = this.marshaller;\n        const eventStreamMember = requestSchema.getEventStreamMember();\n        const unionSchema = requestSchema.getMemberSchema(eventStreamMember);\n        const serializer = this.serializer;\n        const defaultContentType = this.defaultContentType;\n        const initialRequestMarker = Symbol(\"initialRequestMarker\");\n        const eventStreamIterable = {\n            async *[Symbol.asyncIterator]() {\n                if (initialRequest) {\n                    const headers = {\n                        \":event-type\": { type: \"string\", value: \"initial-request\" },\n                        \":message-type\": { type: \"string\", value: \"event\" },\n                        \":content-type\": { type: \"string\", value: defaultContentType },\n                    };\n                    serializer.write(requestSchema, initialRequest);\n                    const body = serializer.flush();\n                    yield {\n                        [initialRequestMarker]: true,\n                        headers,\n                        body,\n                    };\n                }\n                for await (const page of eventStream) {\n                    yield page;\n                }\n            },\n        };\n        return marshaller.serialize(eventStreamIterable, (event) => {\n            if (event[initialRequestMarker]) {\n                return {\n                    headers: event.headers,\n                    body: event.body,\n                };\n            }\n            const unionMember = Object.keys(event).find((key) => {\n                return key !== \"__type\";\n            }) ?? \"\";\n            const { additionalHeaders, body, eventType, explicitPayloadContentType } = this.writeEventBody(unionMember, unionSchema, event);\n            const headers = {\n                \":event-type\": { type: \"string\", value: eventType },\n                \":message-type\": { type: \"string\", value: \"event\" },\n                \":content-type\": { type: \"string\", value: explicitPayloadContentType ?? defaultContentType },\n                ...additionalHeaders,\n            };\n            return {\n                headers,\n                body,\n            };\n        });\n    }\n    async deserializeEventStream({ response, responseSchema, initialResponseContainer, }) {\n        const marshaller = this.marshaller;\n        const eventStreamMember = responseSchema.getEventStreamMember();\n        const unionSchema = responseSchema.getMemberSchema(eventStreamMember);\n        const memberSchemas = unionSchema.getMemberSchemas();\n        const initialResponseMarker = Symbol(\"initialResponseMarker\");\n        const asyncIterable = marshaller.deserialize(response.body, async (event) => {\n            const unionMember = Object.keys(event).find((key) => {\n                return key !== \"__type\";\n            }) ?? \"\";\n            const body = event[unionMember].body;\n            if (unionMember === \"initial-response\") {\n                const dataObject = await this.deserializer.read(responseSchema, body);\n                delete dataObject[eventStreamMember];\n                return {\n                    [initialResponseMarker]: true,\n                    ...dataObject,\n                };\n            }\n            else if (unionMember in memberSchemas) {\n                const eventStreamSchema = memberSchemas[unionMember];\n                if (eventStreamSchema.isStructSchema()) {\n                    const out = {};\n                    let hasBindings = false;\n                    for (const [name, member] of eventStreamSchema.structIterator()) {\n                        const { eventHeader, eventPayload } = member.getMergedTraits();\n                        hasBindings = hasBindings || Boolean(eventHeader || eventPayload);\n                        if (eventPayload) {\n                            if (member.isBlobSchema()) {\n                                out[name] = body;\n                            }\n                            else if (member.isStringSchema()) {\n                                out[name] = (this.serdeContext?.utf8Encoder ?? toUtf8)(body);\n                            }\n                            else if (member.isStructSchema()) {\n                                out[name] = await this.deserializer.read(member, body);\n                            }\n                        }\n                        else if (eventHeader) {\n                            const value = event[unionMember].headers[name]?.value;\n                            if (value != null) {\n                                if (member.isNumericSchema()) {\n                                    if (value && typeof value === \"object\" && \"bytes\" in value) {\n                                        out[name] = BigInt(value.toString());\n                                    }\n                                    else {\n                                        out[name] = Number(value);\n                                    }\n                                }\n                                else {\n                                    out[name] = value;\n                                }\n                            }\n                        }\n                    }\n                    if (hasBindings) {\n                        return {\n                            [unionMember]: out,\n                        };\n                    }\n                }\n                return {\n                    [unionMember]: await this.deserializer.read(eventStreamSchema, body),\n                };\n            }\n            else {\n                return {\n                    $unknown: event,\n                };\n            }\n        });\n        const asyncIterator = asyncIterable[Symbol.asyncIterator]();\n        const firstEvent = await asyncIterator.next();\n        if (firstEvent.done) {\n            return asyncIterable;\n        }\n        if (firstEvent.value?.[initialResponseMarker]) {\n            if (!responseSchema) {\n                throw new Error(\"@smithy::core/protocols - initial-response event encountered in event stream but no response schema given.\");\n            }\n            for (const [key, value] of Object.entries(firstEvent.value)) {\n                initialResponseContainer[key] = value;\n            }\n        }\n        return {\n            async *[Symbol.asyncIterator]() {\n                if (!firstEvent?.value?.[initialResponseMarker]) {\n                    yield firstEvent.value;\n                }\n                while (true) {\n                    const { done, value } = await asyncIterator.next();\n                    if (done) {\n                        break;\n                    }\n                    yield value;\n                }\n            },\n        };\n    }\n    writeEventBody(unionMember, unionSchema, event) {\n        const serializer = this.serializer;\n        let eventType = unionMember;\n        let explicitPayloadMember = null;\n        let explicitPayloadContentType;\n        const isKnownSchema = (() => {\n            const struct = unionSchema.getSchema();\n            return struct[4].includes(unionMember);\n        })();\n        const additionalHeaders = {};\n        if (!isKnownSchema) {\n            const [type, value] = event[unionMember];\n            eventType = type;\n            serializer.write(15, value);\n        }\n        else {\n            const eventSchema = unionSchema.getMemberSchema(unionMember);\n            if (eventSchema.isStructSchema()) {\n                for (const [memberName, memberSchema] of eventSchema.structIterator()) {\n                    const { eventHeader, eventPayload } = memberSchema.getMergedTraits();\n                    if (eventPayload) {\n                        explicitPayloadMember = memberName;\n                        break;\n                    }\n                    else if (eventHeader) {\n                        const value = event[unionMember][memberName];\n                        let type = \"binary\";\n                        if (memberSchema.isNumericSchema()) {\n                            if ((-2) ** 31 <= value && value <= 2 ** 31 - 1) {\n                                type = \"integer\";\n                            }\n                            else {\n                                type = \"long\";\n                            }\n                        }\n                        else if (memberSchema.isTimestampSchema()) {\n                            type = \"timestamp\";\n                        }\n                        else if (memberSchema.isStringSchema()) {\n                            type = \"string\";\n                        }\n                        else if (memberSchema.isBooleanSchema()) {\n                            type = \"boolean\";\n                        }\n                        if (value != null) {\n                            additionalHeaders[memberName] = {\n                                type,\n                                value,\n                            };\n                            delete event[unionMember][memberName];\n                        }\n                    }\n                }\n                if (explicitPayloadMember !== null) {\n                    const payloadSchema = eventSchema.getMemberSchema(explicitPayloadMember);\n                    if (payloadSchema.isBlobSchema()) {\n                        explicitPayloadContentType = \"application/octet-stream\";\n                    }\n                    else if (payloadSchema.isStringSchema()) {\n                        explicitPayloadContentType = \"text/plain\";\n                    }\n                    serializer.write(payloadSchema, event[unionMember][explicitPayloadMember]);\n                }\n                else {\n                    serializer.write(eventSchema, event[unionMember]);\n                }\n            }\n            else {\n                throw new Error(\"@smithy/core/event-streams - non-struct member not supported in event stream union.\");\n            }\n        }\n        const messageSerialization = serializer.flush();\n        const body = typeof messageSerialization === \"string\"\n            ? (this.serdeContext?.utf8Decoder ?? fromUtf8)(messageSerialization)\n            : messageSerialization;\n        return {\n            body,\n            eventType,\n            explicitPayloadContentType,\n            additionalHeaders,\n        };\n    }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}