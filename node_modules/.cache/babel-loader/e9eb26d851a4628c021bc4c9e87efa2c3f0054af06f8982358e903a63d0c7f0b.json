{"ast":null,"code":"import { toHex } from \"@smithy/util-hex-encoding\";\nimport { normalizeProvider } from \"@smithy/util-middleware\";\nimport { escapeUri } from \"@smithy/util-uri-escape\";\nimport { toUint8Array } from \"@smithy/util-utf8\";\nimport { getCanonicalQuery } from \"./getCanonicalQuery\";\nimport { iso8601 } from \"./utilDate\";\nexport class SignatureV4Base {\n  service;\n  regionProvider;\n  credentialProvider;\n  sha256;\n  uriEscapePath;\n  applyChecksum;\n  constructor({\n    applyChecksum,\n    credentials,\n    region,\n    service,\n    sha256,\n    uriEscapePath = true\n  }) {\n    this.service = service;\n    this.sha256 = sha256;\n    this.uriEscapePath = uriEscapePath;\n    this.applyChecksum = typeof applyChecksum === \"boolean\" ? applyChecksum : true;\n    this.regionProvider = normalizeProvider(region);\n    this.credentialProvider = normalizeProvider(credentials);\n  }\n  createCanonicalRequest(request, canonicalHeaders, payloadHash) {\n    const sortedHeaders = Object.keys(canonicalHeaders).sort();\n    return `${request.method}\n${this.getCanonicalPath(request)}\n${getCanonicalQuery(request)}\n${sortedHeaders.map(name => `${name}:${canonicalHeaders[name]}`).join(\"\\n\")}\n\n${sortedHeaders.join(\";\")}\n${payloadHash}`;\n  }\n  async createStringToSign(longDate, credentialScope, canonicalRequest, algorithmIdentifier) {\n    const hash = new this.sha256();\n    hash.update(toUint8Array(canonicalRequest));\n    const hashedRequest = await hash.digest();\n    return `${algorithmIdentifier}\n${longDate}\n${credentialScope}\n${toHex(hashedRequest)}`;\n  }\n  getCanonicalPath({\n    path\n  }) {\n    if (this.uriEscapePath) {\n      const normalizedPathSegments = [];\n      for (const pathSegment of path.split(\"/\")) {\n        if (pathSegment?.length === 0) continue;\n        if (pathSegment === \".\") continue;\n        if (pathSegment === \"..\") {\n          normalizedPathSegments.pop();\n        } else {\n          normalizedPathSegments.push(pathSegment);\n        }\n      }\n      const normalizedPath = `${path?.startsWith(\"/\") ? \"/\" : \"\"}${normalizedPathSegments.join(\"/\")}${normalizedPathSegments.length > 0 && path?.endsWith(\"/\") ? \"/\" : \"\"}`;\n      const doubleEncoded = escapeUri(normalizedPath);\n      return doubleEncoded.replace(/%2F/g, \"/\");\n    }\n    return path;\n  }\n  validateResolvedCredentials(credentials) {\n    if (typeof credentials !== \"object\" || typeof credentials.accessKeyId !== \"string\" || typeof credentials.secretAccessKey !== \"string\") {\n      throw new Error(\"Resolved credential object is not valid\");\n    }\n  }\n  formatDate(now) {\n    const longDate = iso8601(now).replace(/[\\-:]/g, \"\");\n    return {\n      longDate,\n      shortDate: longDate.slice(0, 8)\n    };\n  }\n  getCanonicalHeaderList(headers) {\n    return Object.keys(headers).sort().join(\";\");\n  }\n}","map":{"version":3,"names":["toHex","normalizeProvider","escapeUri","toUint8Array","getCanonicalQuery","iso8601","SignatureV4Base","service","regionProvider","credentialProvider","sha256","uriEscapePath","applyChecksum","constructor","credentials","region","createCanonicalRequest","request","canonicalHeaders","payloadHash","sortedHeaders","Object","keys","sort","method","getCanonicalPath","map","name","join","createStringToSign","longDate","credentialScope","canonicalRequest","algorithmIdentifier","hash","update","hashedRequest","digest","path","normalizedPathSegments","pathSegment","split","length","pop","push","normalizedPath","startsWith","endsWith","doubleEncoded","replace","validateResolvedCredentials","accessKeyId","secretAccessKey","Error","formatDate","now","shortDate","slice","getCanonicalHeaderList","headers"],"sources":["d:/ITechArt/react-lab-2025/application/node_modules/@aws-sdk/middleware-flexible-checksums/node_modules/@smithy/signature-v4/dist-es/SignatureV4Base.js"],"sourcesContent":["import { toHex } from \"@smithy/util-hex-encoding\";\nimport { normalizeProvider } from \"@smithy/util-middleware\";\nimport { escapeUri } from \"@smithy/util-uri-escape\";\nimport { toUint8Array } from \"@smithy/util-utf8\";\nimport { getCanonicalQuery } from \"./getCanonicalQuery\";\nimport { iso8601 } from \"./utilDate\";\nexport class SignatureV4Base {\n    service;\n    regionProvider;\n    credentialProvider;\n    sha256;\n    uriEscapePath;\n    applyChecksum;\n    constructor({ applyChecksum, credentials, region, service, sha256, uriEscapePath = true, }) {\n        this.service = service;\n        this.sha256 = sha256;\n        this.uriEscapePath = uriEscapePath;\n        this.applyChecksum = typeof applyChecksum === \"boolean\" ? applyChecksum : true;\n        this.regionProvider = normalizeProvider(region);\n        this.credentialProvider = normalizeProvider(credentials);\n    }\n    createCanonicalRequest(request, canonicalHeaders, payloadHash) {\n        const sortedHeaders = Object.keys(canonicalHeaders).sort();\n        return `${request.method}\n${this.getCanonicalPath(request)}\n${getCanonicalQuery(request)}\n${sortedHeaders.map((name) => `${name}:${canonicalHeaders[name]}`).join(\"\\n\")}\n\n${sortedHeaders.join(\";\")}\n${payloadHash}`;\n    }\n    async createStringToSign(longDate, credentialScope, canonicalRequest, algorithmIdentifier) {\n        const hash = new this.sha256();\n        hash.update(toUint8Array(canonicalRequest));\n        const hashedRequest = await hash.digest();\n        return `${algorithmIdentifier}\n${longDate}\n${credentialScope}\n${toHex(hashedRequest)}`;\n    }\n    getCanonicalPath({ path }) {\n        if (this.uriEscapePath) {\n            const normalizedPathSegments = [];\n            for (const pathSegment of path.split(\"/\")) {\n                if (pathSegment?.length === 0)\n                    continue;\n                if (pathSegment === \".\")\n                    continue;\n                if (pathSegment === \"..\") {\n                    normalizedPathSegments.pop();\n                }\n                else {\n                    normalizedPathSegments.push(pathSegment);\n                }\n            }\n            const normalizedPath = `${path?.startsWith(\"/\") ? \"/\" : \"\"}${normalizedPathSegments.join(\"/\")}${normalizedPathSegments.length > 0 && path?.endsWith(\"/\") ? \"/\" : \"\"}`;\n            const doubleEncoded = escapeUri(normalizedPath);\n            return doubleEncoded.replace(/%2F/g, \"/\");\n        }\n        return path;\n    }\n    validateResolvedCredentials(credentials) {\n        if (typeof credentials !== \"object\" ||\n            typeof credentials.accessKeyId !== \"string\" ||\n            typeof credentials.secretAccessKey !== \"string\") {\n            throw new Error(\"Resolved credential object is not valid\");\n        }\n    }\n    formatDate(now) {\n        const longDate = iso8601(now).replace(/[\\-:]/g, \"\");\n        return {\n            longDate,\n            shortDate: longDate.slice(0, 8),\n        };\n    }\n    getCanonicalHeaderList(headers) {\n        return Object.keys(headers).sort().join(\";\");\n    }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}