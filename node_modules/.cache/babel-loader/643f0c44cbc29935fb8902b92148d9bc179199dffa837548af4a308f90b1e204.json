{"ast":null,"code":"let parser;\nexport function parseXML(xmlString) {\n  if (!parser) {\n    parser = new DOMParser();\n  }\n  const xmlDocument = parser.parseFromString(xmlString, \"application/xml\");\n  if (xmlDocument.getElementsByTagName(\"parsererror\").length > 0) {\n    throw new Error(\"DOMParser XML parsing error.\");\n  }\n  const xmlToObj = node => {\n    if (node.nodeType === Node.TEXT_NODE) {\n      if (node.textContent?.trim()) {\n        return node.textContent;\n      }\n    }\n    if (node.nodeType === Node.ELEMENT_NODE) {\n      const element = node;\n      if (element.attributes.length === 0 && element.childNodes.length === 0) {\n        return \"\";\n      }\n      const obj = {};\n      const attributes = Array.from(element.attributes);\n      for (const attr of attributes) {\n        obj[`${attr.name}`] = attr.value;\n      }\n      const childNodes = Array.from(element.childNodes);\n      for (const child of childNodes) {\n        const childResult = xmlToObj(child);\n        if (childResult != null) {\n          const childName = child.nodeName;\n          if (childNodes.length === 1 && attributes.length === 0 && childName === \"#text\") {\n            return childResult;\n          }\n          if (obj[childName]) {\n            if (Array.isArray(obj[childName])) {\n              obj[childName].push(childResult);\n            } else {\n              obj[childName] = [obj[childName], childResult];\n            }\n          } else {\n            obj[childName] = childResult;\n          }\n        } else if (childNodes.length === 1 && attributes.length === 0) {\n          return element.textContent;\n        }\n      }\n      return obj;\n    }\n    return null;\n  };\n  return {\n    [xmlDocument.documentElement.nodeName]: xmlToObj(xmlDocument.documentElement)\n  };\n}","map":{"version":3,"names":["parser","parseXML","xmlString","DOMParser","xmlDocument","parseFromString","getElementsByTagName","length","Error","xmlToObj","node","nodeType","Node","TEXT_NODE","textContent","trim","ELEMENT_NODE","element","attributes","childNodes","obj","Array","from","attr","name","value","child","childResult","childName","nodeName","isArray","push","documentElement"],"sources":["D:/ITechArt/react-lab-2025/application/node_modules/@aws-sdk/xml-builder/dist-es/xml-parser.browser.js"],"sourcesContent":["let parser;\nexport function parseXML(xmlString) {\n    if (!parser) {\n        parser = new DOMParser();\n    }\n    const xmlDocument = parser.parseFromString(xmlString, \"application/xml\");\n    if (xmlDocument.getElementsByTagName(\"parsererror\").length > 0) {\n        throw new Error(\"DOMParser XML parsing error.\");\n    }\n    const xmlToObj = (node) => {\n        if (node.nodeType === Node.TEXT_NODE) {\n            if (node.textContent?.trim()) {\n                return node.textContent;\n            }\n        }\n        if (node.nodeType === Node.ELEMENT_NODE) {\n            const element = node;\n            if (element.attributes.length === 0 && element.childNodes.length === 0) {\n                return \"\";\n            }\n            const obj = {};\n            const attributes = Array.from(element.attributes);\n            for (const attr of attributes) {\n                obj[`${attr.name}`] = attr.value;\n            }\n            const childNodes = Array.from(element.childNodes);\n            for (const child of childNodes) {\n                const childResult = xmlToObj(child);\n                if (childResult != null) {\n                    const childName = child.nodeName;\n                    if (childNodes.length === 1 && attributes.length === 0 && childName === \"#text\") {\n                        return childResult;\n                    }\n                    if (obj[childName]) {\n                        if (Array.isArray(obj[childName])) {\n                            obj[childName].push(childResult);\n                        }\n                        else {\n                            obj[childName] = [obj[childName], childResult];\n                        }\n                    }\n                    else {\n                        obj[childName] = childResult;\n                    }\n                }\n                else if (childNodes.length === 1 && attributes.length === 0) {\n                    return element.textContent;\n                }\n            }\n            return obj;\n        }\n        return null;\n    };\n    return {\n        [xmlDocument.documentElement.nodeName]: xmlToObj(xmlDocument.documentElement),\n    };\n}\n"],"mappings":"AAAA,IAAIA,MAAM;AACV,OAAO,SAASC,QAAQA,CAACC,SAAS,EAAE;EAChC,IAAI,CAACF,MAAM,EAAE;IACTA,MAAM,GAAG,IAAIG,SAAS,CAAC,CAAC;EAC5B;EACA,MAAMC,WAAW,GAAGJ,MAAM,CAACK,eAAe,CAACH,SAAS,EAAE,iBAAiB,CAAC;EACxE,IAAIE,WAAW,CAACE,oBAAoB,CAAC,aAAa,CAAC,CAACC,MAAM,GAAG,CAAC,EAAE;IAC5D,MAAM,IAAIC,KAAK,CAAC,8BAA8B,CAAC;EACnD;EACA,MAAMC,QAAQ,GAAIC,IAAI,IAAK;IACvB,IAAIA,IAAI,CAACC,QAAQ,KAAKC,IAAI,CAACC,SAAS,EAAE;MAClC,IAAIH,IAAI,CAACI,WAAW,EAAEC,IAAI,CAAC,CAAC,EAAE;QAC1B,OAAOL,IAAI,CAACI,WAAW;MAC3B;IACJ;IACA,IAAIJ,IAAI,CAACC,QAAQ,KAAKC,IAAI,CAACI,YAAY,EAAE;MACrC,MAAMC,OAAO,GAAGP,IAAI;MACpB,IAAIO,OAAO,CAACC,UAAU,CAACX,MAAM,KAAK,CAAC,IAAIU,OAAO,CAACE,UAAU,CAACZ,MAAM,KAAK,CAAC,EAAE;QACpE,OAAO,EAAE;MACb;MACA,MAAMa,GAAG,GAAG,CAAC,CAAC;MACd,MAAMF,UAAU,GAAGG,KAAK,CAACC,IAAI,CAACL,OAAO,CAACC,UAAU,CAAC;MACjD,KAAK,MAAMK,IAAI,IAAIL,UAAU,EAAE;QAC3BE,GAAG,CAAC,GAAGG,IAAI,CAACC,IAAI,EAAE,CAAC,GAAGD,IAAI,CAACE,KAAK;MACpC;MACA,MAAMN,UAAU,GAAGE,KAAK,CAACC,IAAI,CAACL,OAAO,CAACE,UAAU,CAAC;MACjD,KAAK,MAAMO,KAAK,IAAIP,UAAU,EAAE;QAC5B,MAAMQ,WAAW,GAAGlB,QAAQ,CAACiB,KAAK,CAAC;QACnC,IAAIC,WAAW,IAAI,IAAI,EAAE;UACrB,MAAMC,SAAS,GAAGF,KAAK,CAACG,QAAQ;UAChC,IAAIV,UAAU,CAACZ,MAAM,KAAK,CAAC,IAAIW,UAAU,CAACX,MAAM,KAAK,CAAC,IAAIqB,SAAS,KAAK,OAAO,EAAE;YAC7E,OAAOD,WAAW;UACtB;UACA,IAAIP,GAAG,CAACQ,SAAS,CAAC,EAAE;YAChB,IAAIP,KAAK,CAACS,OAAO,CAACV,GAAG,CAACQ,SAAS,CAAC,CAAC,EAAE;cAC/BR,GAAG,CAACQ,SAAS,CAAC,CAACG,IAAI,CAACJ,WAAW,CAAC;YACpC,CAAC,MACI;cACDP,GAAG,CAACQ,SAAS,CAAC,GAAG,CAACR,GAAG,CAACQ,SAAS,CAAC,EAAED,WAAW,CAAC;YAClD;UACJ,CAAC,MACI;YACDP,GAAG,CAACQ,SAAS,CAAC,GAAGD,WAAW;UAChC;QACJ,CAAC,MACI,IAAIR,UAAU,CAACZ,MAAM,KAAK,CAAC,IAAIW,UAAU,CAACX,MAAM,KAAK,CAAC,EAAE;UACzD,OAAOU,OAAO,CAACH,WAAW;QAC9B;MACJ;MACA,OAAOM,GAAG;IACd;IACA,OAAO,IAAI;EACf,CAAC;EACD,OAAO;IACH,CAAChB,WAAW,CAAC4B,eAAe,CAACH,QAAQ,GAAGpB,QAAQ,CAACL,WAAW,CAAC4B,eAAe;EAChF,CAAC;AACL","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}