{"ast":null,"code":"import { NormalizedSchema } from \"@smithy/core/schema\";\nimport { dateToUtcString, generateIdempotencyToken, LazyJsonString, quoteHeader } from \"@smithy/core/serde\";\nimport { toBase64 } from \"@smithy/util-base64\";\nimport { SerdeContext } from \"../SerdeContext\";\nimport { determineTimestampFormat } from \"./determineTimestampFormat\";\nexport class ToStringShapeSerializer extends SerdeContext {\n  settings;\n  stringBuffer = \"\";\n  constructor(settings) {\n    super();\n    this.settings = settings;\n  }\n  write(schema, value) {\n    const ns = NormalizedSchema.of(schema);\n    switch (typeof value) {\n      case \"object\":\n        if (value === null) {\n          this.stringBuffer = \"null\";\n          return;\n        }\n        if (ns.isTimestampSchema()) {\n          if (!(value instanceof Date)) {\n            throw new Error(`@smithy/core/protocols - received non-Date value ${value} when schema expected Date in ${ns.getName(true)}`);\n          }\n          const format = determineTimestampFormat(ns, this.settings);\n          switch (format) {\n            case 5:\n              this.stringBuffer = value.toISOString().replace(\".000Z\", \"Z\");\n              break;\n            case 6:\n              this.stringBuffer = dateToUtcString(value);\n              break;\n            case 7:\n              this.stringBuffer = String(value.getTime() / 1000);\n              break;\n            default:\n              console.warn(\"Missing timestamp format, using epoch seconds\", value);\n              this.stringBuffer = String(value.getTime() / 1000);\n          }\n          return;\n        }\n        if (ns.isBlobSchema() && \"byteLength\" in value) {\n          this.stringBuffer = (this.serdeContext?.base64Encoder ?? toBase64)(value);\n          return;\n        }\n        if (ns.isListSchema() && Array.isArray(value)) {\n          let buffer = \"\";\n          for (const item of value) {\n            this.write([ns.getValueSchema(), ns.getMergedTraits()], item);\n            const headerItem = this.flush();\n            const serialized = ns.getValueSchema().isTimestampSchema() ? headerItem : quoteHeader(headerItem);\n            if (buffer !== \"\") {\n              buffer += \", \";\n            }\n            buffer += serialized;\n          }\n          this.stringBuffer = buffer;\n          return;\n        }\n        this.stringBuffer = JSON.stringify(value, null, 2);\n        break;\n      case \"string\":\n        const mediaType = ns.getMergedTraits().mediaType;\n        let intermediateValue = value;\n        if (mediaType) {\n          const isJson = mediaType === \"application/json\" || mediaType.endsWith(\"+json\");\n          if (isJson) {\n            intermediateValue = LazyJsonString.from(intermediateValue);\n          }\n          if (ns.getMergedTraits().httpHeader) {\n            this.stringBuffer = (this.serdeContext?.base64Encoder ?? toBase64)(intermediateValue.toString());\n            return;\n          }\n        }\n        this.stringBuffer = value;\n        break;\n      default:\n        if (ns.isIdempotencyToken()) {\n          this.stringBuffer = generateIdempotencyToken();\n        } else {\n          this.stringBuffer = String(value);\n        }\n    }\n  }\n  flush() {\n    const buffer = this.stringBuffer;\n    this.stringBuffer = \"\";\n    return buffer;\n  }\n}","map":{"version":3,"names":["NormalizedSchema","dateToUtcString","generateIdempotencyToken","LazyJsonString","quoteHeader","toBase64","SerdeContext","determineTimestampFormat","ToStringShapeSerializer","settings","stringBuffer","constructor","write","schema","value","ns","of","isTimestampSchema","Date","Error","getName","format","toISOString","replace","String","getTime","console","warn","isBlobSchema","serdeContext","base64Encoder","isListSchema","Array","isArray","buffer","item","getValueSchema","getMergedTraits","headerItem","flush","serialized","JSON","stringify","mediaType","intermediateValue","isJson","endsWith","from","httpHeader","toString","isIdempotencyToken"],"sources":["D:/ITechArt/react-lab-2025/application/node_modules/@aws-sdk/client-s3/node_modules/@smithy/core/dist-es/submodules/protocols/serde/ToStringShapeSerializer.js"],"sourcesContent":["import { NormalizedSchema } from \"@smithy/core/schema\";\nimport { dateToUtcString, generateIdempotencyToken, LazyJsonString, quoteHeader } from \"@smithy/core/serde\";\nimport { toBase64 } from \"@smithy/util-base64\";\nimport { SerdeContext } from \"../SerdeContext\";\nimport { determineTimestampFormat } from \"./determineTimestampFormat\";\nexport class ToStringShapeSerializer extends SerdeContext {\n    settings;\n    stringBuffer = \"\";\n    constructor(settings) {\n        super();\n        this.settings = settings;\n    }\n    write(schema, value) {\n        const ns = NormalizedSchema.of(schema);\n        switch (typeof value) {\n            case \"object\":\n                if (value === null) {\n                    this.stringBuffer = \"null\";\n                    return;\n                }\n                if (ns.isTimestampSchema()) {\n                    if (!(value instanceof Date)) {\n                        throw new Error(`@smithy/core/protocols - received non-Date value ${value} when schema expected Date in ${ns.getName(true)}`);\n                    }\n                    const format = determineTimestampFormat(ns, this.settings);\n                    switch (format) {\n                        case 5:\n                            this.stringBuffer = value.toISOString().replace(\".000Z\", \"Z\");\n                            break;\n                        case 6:\n                            this.stringBuffer = dateToUtcString(value);\n                            break;\n                        case 7:\n                            this.stringBuffer = String(value.getTime() / 1000);\n                            break;\n                        default:\n                            console.warn(\"Missing timestamp format, using epoch seconds\", value);\n                            this.stringBuffer = String(value.getTime() / 1000);\n                    }\n                    return;\n                }\n                if (ns.isBlobSchema() && \"byteLength\" in value) {\n                    this.stringBuffer = (this.serdeContext?.base64Encoder ?? toBase64)(value);\n                    return;\n                }\n                if (ns.isListSchema() && Array.isArray(value)) {\n                    let buffer = \"\";\n                    for (const item of value) {\n                        this.write([ns.getValueSchema(), ns.getMergedTraits()], item);\n                        const headerItem = this.flush();\n                        const serialized = ns.getValueSchema().isTimestampSchema() ? headerItem : quoteHeader(headerItem);\n                        if (buffer !== \"\") {\n                            buffer += \", \";\n                        }\n                        buffer += serialized;\n                    }\n                    this.stringBuffer = buffer;\n                    return;\n                }\n                this.stringBuffer = JSON.stringify(value, null, 2);\n                break;\n            case \"string\":\n                const mediaType = ns.getMergedTraits().mediaType;\n                let intermediateValue = value;\n                if (mediaType) {\n                    const isJson = mediaType === \"application/json\" || mediaType.endsWith(\"+json\");\n                    if (isJson) {\n                        intermediateValue = LazyJsonString.from(intermediateValue);\n                    }\n                    if (ns.getMergedTraits().httpHeader) {\n                        this.stringBuffer = (this.serdeContext?.base64Encoder ?? toBase64)(intermediateValue.toString());\n                        return;\n                    }\n                }\n                this.stringBuffer = value;\n                break;\n            default:\n                if (ns.isIdempotencyToken()) {\n                    this.stringBuffer = generateIdempotencyToken();\n                }\n                else {\n                    this.stringBuffer = String(value);\n                }\n        }\n    }\n    flush() {\n        const buffer = this.stringBuffer;\n        this.stringBuffer = \"\";\n        return buffer;\n    }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}