{"ast":null,"code":"import { AbortMultipartUploadCommand, ChecksumAlgorithm, CompleteMultipartUploadCommand, CreateMultipartUploadCommand, PutObjectCommand, PutObjectTaggingCommand, UploadPartCommand } from \"@aws-sdk/client-s3\";\nimport { AbortController } from \"@smithy/abort-controller\";\nimport { getEndpointFromInstructions, toEndpointV1 } from \"@smithy/middleware-endpoint\";\nimport { extendedEncodeURIComponent } from \"@smithy/smithy-client\";\nimport { EventEmitter } from \"events\";\nimport { byteLength } from \"./byteLength\";\nimport { byteLengthSource } from \"./byteLengthSource\";\nimport { getChunk } from \"./chunker\";\nexport class Upload extends EventEmitter {\n  static MIN_PART_SIZE = 1024 * 1024 * 5;\n  MAX_PARTS = 10_000;\n  queueSize = 4;\n  partSize;\n  leavePartsOnError = false;\n  tags = [];\n  client;\n  params;\n  totalBytes;\n  totalBytesSource;\n  bytesUploadedSoFar;\n  abortController;\n  concurrentUploaders = [];\n  createMultiPartPromise;\n  abortMultipartUploadCommand = null;\n  uploadedParts = [];\n  uploadEnqueuedPartsCount = 0;\n  expectedPartsCount;\n  uploadId;\n  uploadEvent;\n  isMultiPart = true;\n  singleUploadResult;\n  sent = false;\n  constructor(options) {\n    super();\n    this.queueSize = options.queueSize || this.queueSize;\n    this.leavePartsOnError = options.leavePartsOnError || this.leavePartsOnError;\n    this.tags = options.tags || this.tags;\n    this.client = options.client;\n    this.params = options.params;\n    if (!this.params) {\n      throw new Error(`InputError: Upload requires params to be passed to upload.`);\n    }\n    this.totalBytes = this.params.ContentLength ?? byteLength(this.params.Body);\n    this.totalBytesSource = byteLengthSource(this.params.Body, this.params.ContentLength);\n    this.bytesUploadedSoFar = 0;\n    this.abortController = options.abortController ?? new AbortController();\n    this.partSize = options.partSize || Math.max(Upload.MIN_PART_SIZE, Math.floor((this.totalBytes || 0) / this.MAX_PARTS));\n    if (this.totalBytes !== undefined) {\n      this.expectedPartsCount = Math.ceil(this.totalBytes / this.partSize);\n    }\n    this.__validateInput();\n  }\n  async abort() {\n    this.abortController.abort();\n  }\n  async done() {\n    if (this.sent) {\n      throw new Error(\"@aws-sdk/lib-storage: this instance of Upload has already executed .done(). Create a new instance.\");\n    }\n    this.sent = true;\n    return await Promise.race([this.__doMultipartUpload(), this.__abortTimeout(this.abortController.signal)]);\n  }\n  on(event, listener) {\n    this.uploadEvent = event;\n    return super.on(event, listener);\n  }\n  async __uploadUsingPut(dataPart) {\n    this.isMultiPart = false;\n    const params = {\n      ...this.params,\n      Body: dataPart.data\n    };\n    const clientConfig = this.client.config;\n    const requestHandler = clientConfig.requestHandler;\n    const eventEmitter = requestHandler instanceof EventEmitter ? requestHandler : null;\n    const uploadEventListener = event => {\n      this.bytesUploadedSoFar = event.loaded;\n      this.totalBytes = event.total;\n      this.__notifyProgress({\n        loaded: this.bytesUploadedSoFar,\n        total: this.totalBytes,\n        part: dataPart.partNumber,\n        Key: this.params.Key,\n        Bucket: this.params.Bucket\n      });\n    };\n    if (eventEmitter !== null) {\n      eventEmitter.on(\"xhr.upload.progress\", uploadEventListener);\n    }\n    const resolved = await Promise.all([this.client.send(new PutObjectCommand(params)), clientConfig?.endpoint?.()]);\n    const putResult = resolved[0];\n    let endpoint = resolved[1];\n    if (!endpoint) {\n      endpoint = toEndpointV1(await getEndpointFromInstructions(params, PutObjectCommand, {\n        ...clientConfig\n      }));\n    }\n    if (!endpoint) {\n      throw new Error('Could not resolve endpoint from S3 \"client.config.endpoint()\" nor EndpointsV2.');\n    }\n    if (eventEmitter !== null) {\n      eventEmitter.off(\"xhr.upload.progress\", uploadEventListener);\n    }\n    const locationKey = this.params.Key.split(\"/\").map(segment => extendedEncodeURIComponent(segment)).join(\"/\");\n    const locationBucket = extendedEncodeURIComponent(this.params.Bucket);\n    const Location = (() => {\n      const endpointHostnameIncludesBucket = endpoint.hostname.startsWith(`${locationBucket}.`);\n      const forcePathStyle = this.client.config.forcePathStyle;\n      const optionalPort = endpoint.port ? `:${endpoint.port}` : ``;\n      if (forcePathStyle) {\n        return `${endpoint.protocol}//${endpoint.hostname}${optionalPort}/${locationBucket}/${locationKey}`;\n      }\n      if (endpointHostnameIncludesBucket) {\n        return `${endpoint.protocol}//${endpoint.hostname}${optionalPort}/${locationKey}`;\n      }\n      return `${endpoint.protocol}//${locationBucket}.${endpoint.hostname}${optionalPort}/${locationKey}`;\n    })();\n    this.singleUploadResult = {\n      ...putResult,\n      Bucket: this.params.Bucket,\n      Key: this.params.Key,\n      Location\n    };\n    const totalSize = byteLength(dataPart.data);\n    this.__notifyProgress({\n      loaded: totalSize,\n      total: totalSize,\n      part: 1,\n      Key: this.params.Key,\n      Bucket: this.params.Bucket\n    });\n  }\n  async __createMultipartUpload() {\n    const requestChecksumCalculation = await this.client.config.requestChecksumCalculation();\n    if (!this.createMultiPartPromise) {\n      const createCommandParams = {\n        ...this.params,\n        Body: undefined\n      };\n      if (requestChecksumCalculation === \"WHEN_SUPPORTED\") {\n        createCommandParams.ChecksumAlgorithm = this.params.ChecksumAlgorithm || ChecksumAlgorithm.CRC32;\n      }\n      this.createMultiPartPromise = this.client.send(new CreateMultipartUploadCommand(createCommandParams)).then(createMpuResponse => {\n        this.abortMultipartUploadCommand = new AbortMultipartUploadCommand({\n          Bucket: this.params.Bucket,\n          Key: this.params.Key,\n          UploadId: createMpuResponse.UploadId\n        });\n        return createMpuResponse;\n      });\n    }\n    return this.createMultiPartPromise;\n  }\n  async __doConcurrentUpload(dataFeeder) {\n    for await (const dataPart of dataFeeder) {\n      if (this.uploadEnqueuedPartsCount > this.MAX_PARTS) {\n        throw new Error(`Exceeded ${this.MAX_PARTS} parts in multipart upload to Bucket: ${this.params.Bucket} Key: ${this.params.Key}.`);\n      }\n      if (this.abortController.signal.aborted) {\n        return;\n      }\n      if (dataPart.partNumber === 1 && dataPart.lastPart) {\n        return await this.__uploadUsingPut(dataPart);\n      }\n      if (!this.uploadId) {\n        const {\n          UploadId\n        } = await this.__createMultipartUpload();\n        this.uploadId = UploadId;\n        if (this.abortController.signal.aborted) {\n          return;\n        }\n      }\n      const partSize = byteLength(dataPart.data) || 0;\n      const requestHandler = this.client.config.requestHandler;\n      const eventEmitter = requestHandler instanceof EventEmitter ? requestHandler : null;\n      let lastSeenBytes = 0;\n      const uploadEventListener = (event, request) => {\n        const requestPartSize = Number(request.query[\"partNumber\"]) || -1;\n        if (requestPartSize !== dataPart.partNumber) {\n          return;\n        }\n        if (event.total && partSize) {\n          this.bytesUploadedSoFar += event.loaded - lastSeenBytes;\n          lastSeenBytes = event.loaded;\n        }\n        this.__notifyProgress({\n          loaded: this.bytesUploadedSoFar,\n          total: this.totalBytes,\n          part: dataPart.partNumber,\n          Key: this.params.Key,\n          Bucket: this.params.Bucket\n        });\n      };\n      if (eventEmitter !== null) {\n        eventEmitter.on(\"xhr.upload.progress\", uploadEventListener);\n      }\n      this.uploadEnqueuedPartsCount += 1;\n      this.__validateUploadPart(dataPart);\n      const partResult = await this.client.send(new UploadPartCommand({\n        ...this.params,\n        ContentLength: undefined,\n        UploadId: this.uploadId,\n        Body: dataPart.data,\n        PartNumber: dataPart.partNumber\n      }));\n      if (eventEmitter !== null) {\n        eventEmitter.off(\"xhr.upload.progress\", uploadEventListener);\n      }\n      if (this.abortController.signal.aborted) {\n        return;\n      }\n      if (!partResult.ETag) {\n        throw new Error(`Part ${dataPart.partNumber} is missing ETag in UploadPart response. Missing Bucket CORS configuration for ETag header?`);\n      }\n      this.uploadedParts.push({\n        PartNumber: dataPart.partNumber,\n        ETag: partResult.ETag,\n        ...(partResult.ChecksumCRC32 && {\n          ChecksumCRC32: partResult.ChecksumCRC32\n        }),\n        ...(partResult.ChecksumCRC32C && {\n          ChecksumCRC32C: partResult.ChecksumCRC32C\n        }),\n        ...(partResult.ChecksumSHA1 && {\n          ChecksumSHA1: partResult.ChecksumSHA1\n        }),\n        ...(partResult.ChecksumSHA256 && {\n          ChecksumSHA256: partResult.ChecksumSHA256\n        })\n      });\n      if (eventEmitter === null) {\n        this.bytesUploadedSoFar += partSize;\n      }\n      this.__notifyProgress({\n        loaded: this.bytesUploadedSoFar,\n        total: this.totalBytes,\n        part: dataPart.partNumber,\n        Key: this.params.Key,\n        Bucket: this.params.Bucket\n      });\n    }\n  }\n  async __doMultipartUpload() {\n    const dataFeeder = getChunk(this.params.Body, this.partSize);\n    const concurrentUploaderFailures = [];\n    for (let index = 0; index < this.queueSize; index++) {\n      const currentUpload = this.__doConcurrentUpload(dataFeeder).catch(err => {\n        concurrentUploaderFailures.push(err);\n      });\n      this.concurrentUploaders.push(currentUpload);\n    }\n    await Promise.all(this.concurrentUploaders);\n    if (concurrentUploaderFailures.length >= 1) {\n      await this.markUploadAsAborted();\n      throw concurrentUploaderFailures[0];\n    }\n    if (this.abortController.signal.aborted) {\n      await this.markUploadAsAborted();\n      throw Object.assign(new Error(\"Upload aborted.\"), {\n        name: \"AbortError\"\n      });\n    }\n    let result;\n    if (this.isMultiPart) {\n      const {\n        expectedPartsCount,\n        uploadedParts,\n        totalBytes,\n        totalBytesSource\n      } = this;\n      if (totalBytes !== undefined && expectedPartsCount !== undefined && uploadedParts.length !== expectedPartsCount) {\n        throw new Error(`Expected ${expectedPartsCount} part(s) but uploaded ${uploadedParts.length} part(s).\nThe expected part count is based on the byte-count of the input.params.Body,\nwhich was read from ${totalBytesSource} and is ${totalBytes}.\nIf this is not correct, provide an override value by setting a number\nto input.params.ContentLength in bytes.\n`);\n      }\n      this.uploadedParts.sort((a, b) => a.PartNumber - b.PartNumber);\n      const uploadCompleteParams = {\n        ...this.params,\n        Body: undefined,\n        UploadId: this.uploadId,\n        MultipartUpload: {\n          Parts: this.uploadedParts\n        }\n      };\n      result = await this.client.send(new CompleteMultipartUploadCommand(uploadCompleteParams));\n      if (typeof result?.Location === \"string\" && result.Location.includes(\"%2F\")) {\n        result.Location = result.Location.replace(/%2F/g, \"/\");\n      }\n    } else {\n      result = this.singleUploadResult;\n    }\n    this.abortMultipartUploadCommand = null;\n    if (this.tags.length) {\n      await this.client.send(new PutObjectTaggingCommand({\n        ...this.params,\n        Tagging: {\n          TagSet: this.tags\n        }\n      }));\n    }\n    return result;\n  }\n  async markUploadAsAborted() {\n    if (this.uploadId && !this.leavePartsOnError && null !== this.abortMultipartUploadCommand) {\n      await this.client.send(this.abortMultipartUploadCommand);\n      this.abortMultipartUploadCommand = null;\n    }\n  }\n  __notifyProgress(progress) {\n    if (this.uploadEvent) {\n      this.emit(this.uploadEvent, progress);\n    }\n  }\n  async __abortTimeout(abortSignal) {\n    return new Promise((resolve, reject) => {\n      abortSignal.onabort = () => {\n        const abortError = new Error(\"Upload aborted.\");\n        abortError.name = \"AbortError\";\n        reject(abortError);\n      };\n    });\n  }\n  __validateUploadPart(dataPart) {\n    const actualPartSize = byteLength(dataPart.data);\n    if (actualPartSize === undefined) {\n      throw new Error(`A dataPart was generated without a measurable data chunk size for part number ${dataPart.partNumber}`);\n    }\n    if (dataPart.partNumber === 1 && dataPart.lastPart) {\n      return;\n    }\n    if (!dataPart.lastPart && actualPartSize !== this.partSize) {\n      throw new Error(`The byte size for part number ${dataPart.partNumber}, size ${actualPartSize} does not match expected size ${this.partSize}`);\n    }\n  }\n  __validateInput() {\n    if (!this.client) {\n      throw new Error(`InputError: Upload requires a AWS client to do uploads with.`);\n    }\n    if (this.partSize < Upload.MIN_PART_SIZE) {\n      throw new Error(`EntityTooSmall: Your proposed upload part size [${this.partSize}] is smaller than the minimum allowed size [${Upload.MIN_PART_SIZE}] (5MB)`);\n    }\n    if (this.queueSize < 1) {\n      throw new Error(`Queue size: Must have at least one uploading queue.`);\n    }\n  }\n}","map":{"version":3,"names":["AbortMultipartUploadCommand","ChecksumAlgorithm","CompleteMultipartUploadCommand","CreateMultipartUploadCommand","PutObjectCommand","PutObjectTaggingCommand","UploadPartCommand","AbortController","getEndpointFromInstructions","toEndpointV1","extendedEncodeURIComponent","EventEmitter","byteLength","byteLengthSource","getChunk","Upload","MIN_PART_SIZE","MAX_PARTS","queueSize","partSize","leavePartsOnError","tags","client","params","totalBytes","totalBytesSource","bytesUploadedSoFar","abortController","concurrentUploaders","createMultiPartPromise","abortMultipartUploadCommand","uploadedParts","uploadEnqueuedPartsCount","expectedPartsCount","uploadId","uploadEvent","isMultiPart","singleUploadResult","sent","constructor","options","Error","ContentLength","Body","Math","max","floor","undefined","ceil","__validateInput","abort","done","Promise","race","__doMultipartUpload","__abortTimeout","signal","on","event","listener","__uploadUsingPut","dataPart","data","clientConfig","config","requestHandler","eventEmitter","uploadEventListener","loaded","total","__notifyProgress","part","partNumber","Key","Bucket","resolved","all","send","endpoint","putResult","off","locationKey","split","map","segment","join","locationBucket","Location","endpointHostnameIncludesBucket","hostname","startsWith","forcePathStyle","optionalPort","port","protocol","totalSize","__createMultipartUpload","requestChecksumCalculation","createCommandParams","CRC32","then","createMpuResponse","UploadId","__doConcurrentUpload","dataFeeder","aborted","lastPart","lastSeenBytes","request","requestPartSize","Number","query","__validateUploadPart","partResult","PartNumber","ETag","push","ChecksumCRC32","ChecksumCRC32C","ChecksumSHA1","ChecksumSHA256","concurrentUploaderFailures","index","currentUpload","catch","err","length","markUploadAsAborted","Object","assign","name","result","sort","a","b","uploadCompleteParams","MultipartUpload","Parts","includes","replace","Tagging","TagSet","progress","emit","abortSignal","resolve","reject","onabort","abortError","actualPartSize"],"sources":["D:/ITechArt/react-lab-2025/application/amplify-s3-gallery/node_modules/@aws-sdk/lib-storage/dist-es/Upload.js"],"sourcesContent":["import { AbortMultipartUploadCommand, ChecksumAlgorithm, CompleteMultipartUploadCommand, CreateMultipartUploadCommand, PutObjectCommand, PutObjectTaggingCommand, UploadPartCommand, } from \"@aws-sdk/client-s3\";\nimport { AbortController } from \"@smithy/abort-controller\";\nimport { getEndpointFromInstructions, toEndpointV1, } from \"@smithy/middleware-endpoint\";\nimport { extendedEncodeURIComponent } from \"@smithy/smithy-client\";\nimport { EventEmitter } from \"events\";\nimport { byteLength } from \"./byteLength\";\nimport { byteLengthSource } from \"./byteLengthSource\";\nimport { getChunk } from \"./chunker\";\nexport class Upload extends EventEmitter {\n    static MIN_PART_SIZE = 1024 * 1024 * 5;\n    MAX_PARTS = 10_000;\n    queueSize = 4;\n    partSize;\n    leavePartsOnError = false;\n    tags = [];\n    client;\n    params;\n    totalBytes;\n    totalBytesSource;\n    bytesUploadedSoFar;\n    abortController;\n    concurrentUploaders = [];\n    createMultiPartPromise;\n    abortMultipartUploadCommand = null;\n    uploadedParts = [];\n    uploadEnqueuedPartsCount = 0;\n    expectedPartsCount;\n    uploadId;\n    uploadEvent;\n    isMultiPart = true;\n    singleUploadResult;\n    sent = false;\n    constructor(options) {\n        super();\n        this.queueSize = options.queueSize || this.queueSize;\n        this.leavePartsOnError = options.leavePartsOnError || this.leavePartsOnError;\n        this.tags = options.tags || this.tags;\n        this.client = options.client;\n        this.params = options.params;\n        if (!this.params) {\n            throw new Error(`InputError: Upload requires params to be passed to upload.`);\n        }\n        this.totalBytes = this.params.ContentLength ?? byteLength(this.params.Body);\n        this.totalBytesSource = byteLengthSource(this.params.Body, this.params.ContentLength);\n        this.bytesUploadedSoFar = 0;\n        this.abortController = options.abortController ?? new AbortController();\n        this.partSize =\n            options.partSize || Math.max(Upload.MIN_PART_SIZE, Math.floor((this.totalBytes || 0) / this.MAX_PARTS));\n        if (this.totalBytes !== undefined) {\n            this.expectedPartsCount = Math.ceil(this.totalBytes / this.partSize);\n        }\n        this.__validateInput();\n    }\n    async abort() {\n        this.abortController.abort();\n    }\n    async done() {\n        if (this.sent) {\n            throw new Error(\"@aws-sdk/lib-storage: this instance of Upload has already executed .done(). Create a new instance.\");\n        }\n        this.sent = true;\n        return await Promise.race([this.__doMultipartUpload(), this.__abortTimeout(this.abortController.signal)]);\n    }\n    on(event, listener) {\n        this.uploadEvent = event;\n        return super.on(event, listener);\n    }\n    async __uploadUsingPut(dataPart) {\n        this.isMultiPart = false;\n        const params = { ...this.params, Body: dataPart.data };\n        const clientConfig = this.client.config;\n        const requestHandler = clientConfig.requestHandler;\n        const eventEmitter = requestHandler instanceof EventEmitter ? requestHandler : null;\n        const uploadEventListener = (event) => {\n            this.bytesUploadedSoFar = event.loaded;\n            this.totalBytes = event.total;\n            this.__notifyProgress({\n                loaded: this.bytesUploadedSoFar,\n                total: this.totalBytes,\n                part: dataPart.partNumber,\n                Key: this.params.Key,\n                Bucket: this.params.Bucket,\n            });\n        };\n        if (eventEmitter !== null) {\n            eventEmitter.on(\"xhr.upload.progress\", uploadEventListener);\n        }\n        const resolved = await Promise.all([this.client.send(new PutObjectCommand(params)), clientConfig?.endpoint?.()]);\n        const putResult = resolved[0];\n        let endpoint = resolved[1];\n        if (!endpoint) {\n            endpoint = toEndpointV1(await getEndpointFromInstructions(params, PutObjectCommand, {\n                ...clientConfig,\n            }));\n        }\n        if (!endpoint) {\n            throw new Error('Could not resolve endpoint from S3 \"client.config.endpoint()\" nor EndpointsV2.');\n        }\n        if (eventEmitter !== null) {\n            eventEmitter.off(\"xhr.upload.progress\", uploadEventListener);\n        }\n        const locationKey = this.params\n            .Key.split(\"/\")\n            .map((segment) => extendedEncodeURIComponent(segment))\n            .join(\"/\");\n        const locationBucket = extendedEncodeURIComponent(this.params.Bucket);\n        const Location = (() => {\n            const endpointHostnameIncludesBucket = endpoint.hostname.startsWith(`${locationBucket}.`);\n            const forcePathStyle = this.client.config.forcePathStyle;\n            const optionalPort = endpoint.port ? `:${endpoint.port}` : ``;\n            if (forcePathStyle) {\n                return `${endpoint.protocol}//${endpoint.hostname}${optionalPort}/${locationBucket}/${locationKey}`;\n            }\n            if (endpointHostnameIncludesBucket) {\n                return `${endpoint.protocol}//${endpoint.hostname}${optionalPort}/${locationKey}`;\n            }\n            return `${endpoint.protocol}//${locationBucket}.${endpoint.hostname}${optionalPort}/${locationKey}`;\n        })();\n        this.singleUploadResult = {\n            ...putResult,\n            Bucket: this.params.Bucket,\n            Key: this.params.Key,\n            Location,\n        };\n        const totalSize = byteLength(dataPart.data);\n        this.__notifyProgress({\n            loaded: totalSize,\n            total: totalSize,\n            part: 1,\n            Key: this.params.Key,\n            Bucket: this.params.Bucket,\n        });\n    }\n    async __createMultipartUpload() {\n        const requestChecksumCalculation = await this.client.config.requestChecksumCalculation();\n        if (!this.createMultiPartPromise) {\n            const createCommandParams = { ...this.params, Body: undefined };\n            if (requestChecksumCalculation === \"WHEN_SUPPORTED\") {\n                createCommandParams.ChecksumAlgorithm = this.params.ChecksumAlgorithm || ChecksumAlgorithm.CRC32;\n            }\n            this.createMultiPartPromise = this.client\n                .send(new CreateMultipartUploadCommand(createCommandParams))\n                .then((createMpuResponse) => {\n                this.abortMultipartUploadCommand = new AbortMultipartUploadCommand({\n                    Bucket: this.params.Bucket,\n                    Key: this.params.Key,\n                    UploadId: createMpuResponse.UploadId,\n                });\n                return createMpuResponse;\n            });\n        }\n        return this.createMultiPartPromise;\n    }\n    async __doConcurrentUpload(dataFeeder) {\n        for await (const dataPart of dataFeeder) {\n            if (this.uploadEnqueuedPartsCount > this.MAX_PARTS) {\n                throw new Error(`Exceeded ${this.MAX_PARTS} parts in multipart upload to Bucket: ${this.params.Bucket} Key: ${this.params.Key}.`);\n            }\n            if (this.abortController.signal.aborted) {\n                return;\n            }\n            if (dataPart.partNumber === 1 && dataPart.lastPart) {\n                return await this.__uploadUsingPut(dataPart);\n            }\n            if (!this.uploadId) {\n                const { UploadId } = await this.__createMultipartUpload();\n                this.uploadId = UploadId;\n                if (this.abortController.signal.aborted) {\n                    return;\n                }\n            }\n            const partSize = byteLength(dataPart.data) || 0;\n            const requestHandler = this.client.config.requestHandler;\n            const eventEmitter = requestHandler instanceof EventEmitter ? requestHandler : null;\n            let lastSeenBytes = 0;\n            const uploadEventListener = (event, request) => {\n                const requestPartSize = Number(request.query[\"partNumber\"]) || -1;\n                if (requestPartSize !== dataPart.partNumber) {\n                    return;\n                }\n                if (event.total && partSize) {\n                    this.bytesUploadedSoFar += event.loaded - lastSeenBytes;\n                    lastSeenBytes = event.loaded;\n                }\n                this.__notifyProgress({\n                    loaded: this.bytesUploadedSoFar,\n                    total: this.totalBytes,\n                    part: dataPart.partNumber,\n                    Key: this.params.Key,\n                    Bucket: this.params.Bucket,\n                });\n            };\n            if (eventEmitter !== null) {\n                eventEmitter.on(\"xhr.upload.progress\", uploadEventListener);\n            }\n            this.uploadEnqueuedPartsCount += 1;\n            this.__validateUploadPart(dataPart);\n            const partResult = await this.client.send(new UploadPartCommand({\n                ...this.params,\n                ContentLength: undefined,\n                UploadId: this.uploadId,\n                Body: dataPart.data,\n                PartNumber: dataPart.partNumber,\n            }));\n            if (eventEmitter !== null) {\n                eventEmitter.off(\"xhr.upload.progress\", uploadEventListener);\n            }\n            if (this.abortController.signal.aborted) {\n                return;\n            }\n            if (!partResult.ETag) {\n                throw new Error(`Part ${dataPart.partNumber} is missing ETag in UploadPart response. Missing Bucket CORS configuration for ETag header?`);\n            }\n            this.uploadedParts.push({\n                PartNumber: dataPart.partNumber,\n                ETag: partResult.ETag,\n                ...(partResult.ChecksumCRC32 && { ChecksumCRC32: partResult.ChecksumCRC32 }),\n                ...(partResult.ChecksumCRC32C && { ChecksumCRC32C: partResult.ChecksumCRC32C }),\n                ...(partResult.ChecksumSHA1 && { ChecksumSHA1: partResult.ChecksumSHA1 }),\n                ...(partResult.ChecksumSHA256 && { ChecksumSHA256: partResult.ChecksumSHA256 }),\n            });\n            if (eventEmitter === null) {\n                this.bytesUploadedSoFar += partSize;\n            }\n            this.__notifyProgress({\n                loaded: this.bytesUploadedSoFar,\n                total: this.totalBytes,\n                part: dataPart.partNumber,\n                Key: this.params.Key,\n                Bucket: this.params.Bucket,\n            });\n        }\n    }\n    async __doMultipartUpload() {\n        const dataFeeder = getChunk(this.params.Body, this.partSize);\n        const concurrentUploaderFailures = [];\n        for (let index = 0; index < this.queueSize; index++) {\n            const currentUpload = this.__doConcurrentUpload(dataFeeder).catch((err) => {\n                concurrentUploaderFailures.push(err);\n            });\n            this.concurrentUploaders.push(currentUpload);\n        }\n        await Promise.all(this.concurrentUploaders);\n        if (concurrentUploaderFailures.length >= 1) {\n            await this.markUploadAsAborted();\n            throw concurrentUploaderFailures[0];\n        }\n        if (this.abortController.signal.aborted) {\n            await this.markUploadAsAborted();\n            throw Object.assign(new Error(\"Upload aborted.\"), { name: \"AbortError\" });\n        }\n        let result;\n        if (this.isMultiPart) {\n            const { expectedPartsCount, uploadedParts, totalBytes, totalBytesSource } = this;\n            if (totalBytes !== undefined && expectedPartsCount !== undefined && uploadedParts.length !== expectedPartsCount) {\n                throw new Error(`Expected ${expectedPartsCount} part(s) but uploaded ${uploadedParts.length} part(s).\nThe expected part count is based on the byte-count of the input.params.Body,\nwhich was read from ${totalBytesSource} and is ${totalBytes}.\nIf this is not correct, provide an override value by setting a number\nto input.params.ContentLength in bytes.\n`);\n            }\n            this.uploadedParts.sort((a, b) => a.PartNumber - b.PartNumber);\n            const uploadCompleteParams = {\n                ...this.params,\n                Body: undefined,\n                UploadId: this.uploadId,\n                MultipartUpload: {\n                    Parts: this.uploadedParts,\n                },\n            };\n            result = await this.client.send(new CompleteMultipartUploadCommand(uploadCompleteParams));\n            if (typeof result?.Location === \"string\" && result.Location.includes(\"%2F\")) {\n                result.Location = result.Location.replace(/%2F/g, \"/\");\n            }\n        }\n        else {\n            result = this.singleUploadResult;\n        }\n        this.abortMultipartUploadCommand = null;\n        if (this.tags.length) {\n            await this.client.send(new PutObjectTaggingCommand({\n                ...this.params,\n                Tagging: {\n                    TagSet: this.tags,\n                },\n            }));\n        }\n        return result;\n    }\n    async markUploadAsAborted() {\n        if (this.uploadId && !this.leavePartsOnError && null !== this.abortMultipartUploadCommand) {\n            await this.client.send(this.abortMultipartUploadCommand);\n            this.abortMultipartUploadCommand = null;\n        }\n    }\n    __notifyProgress(progress) {\n        if (this.uploadEvent) {\n            this.emit(this.uploadEvent, progress);\n        }\n    }\n    async __abortTimeout(abortSignal) {\n        return new Promise((resolve, reject) => {\n            abortSignal.onabort = () => {\n                const abortError = new Error(\"Upload aborted.\");\n                abortError.name = \"AbortError\";\n                reject(abortError);\n            };\n        });\n    }\n    __validateUploadPart(dataPart) {\n        const actualPartSize = byteLength(dataPart.data);\n        if (actualPartSize === undefined) {\n            throw new Error(`A dataPart was generated without a measurable data chunk size for part number ${dataPart.partNumber}`);\n        }\n        if (dataPart.partNumber === 1 && dataPart.lastPart) {\n            return;\n        }\n        if (!dataPart.lastPart && actualPartSize !== this.partSize) {\n            throw new Error(`The byte size for part number ${dataPart.partNumber}, size ${actualPartSize} does not match expected size ${this.partSize}`);\n        }\n    }\n    __validateInput() {\n        if (!this.client) {\n            throw new Error(`InputError: Upload requires a AWS client to do uploads with.`);\n        }\n        if (this.partSize < Upload.MIN_PART_SIZE) {\n            throw new Error(`EntityTooSmall: Your proposed upload part size [${this.partSize}] is smaller than the minimum allowed size [${Upload.MIN_PART_SIZE}] (5MB)`);\n        }\n        if (this.queueSize < 1) {\n            throw new Error(`Queue size: Must have at least one uploading queue.`);\n        }\n    }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}